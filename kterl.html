<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module kterl</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module kterl</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>
kterl is an Erlang interface to the Kyoto Tycoon cache/storage server.

<p><b>Version:</b> 1.0.0</p>
<p><b>Authors:</b> Rich Beerman (<a href="mailto:rbeer@beerman.org"><tt>rbeer@beerman.org</tt></a>).</p>

<h2><a name="description">Description</a></h2><p>
kterl is an Erlang interface to the Kyoto Tycoon cache/storage server.</p>

<h3><a name="features">features</a></h3>
<ul> 
<li>%100 feature support of Kyoto Tycoon's HTTP and binary protocols.</li>
<li>Full OTP compliance.</li>
<li>High performance, robust, and non-blocking protocol handling.</li>
<li>A documented API that provides a simple, clean, and idiomatic interface.</li>
</ul>

<p> </p><p>Kyoto Tycoon supports standard key/value database calls, such as
set, add, remove, seize, and so on, but there are specific features
and behaviors to be aware of while exploring the documentation:</p>

<h4><a name="binary_protocol">binary protocol</a></h4>

<p>Clients interact with Kyoto Tycoon through HTTP or a binary protocol,
kterl supports both methods on the same socket connection. The binary
calls are <a href="#bin_set_bulk-2"><code>bin_set_bulk/2</code></a>, <a href="#bin_get_bulk-2"><code>bin_get_bulk/2</code></a>, <a href="#bin_remove_bulk-2"><code>bin_remove_bulk/2</code></a>, and <a href="#bin_play_script-2"><code>bin_play_script/2</code></a>. Although these
methods are not as feature rich as their HTTP based siblings, they do
provide significant performance advantages.</p>

<h4><a name="multiple_databases">multiple databases</a></h4>

<p>Kyoto Tycoon supports multiple databases and database types, and all
of kterl's calls have at least one variation that provides the option
to specify a database to operate on.</p>

<p> </p>

<p>The HTTP calls accept a database specifier of a string/binary, which
is the database's filename without the path (such as "test.kct"), or a
zero-based integer. For example, if ktserver is started as:</p>

<pre>    ktserver /path/to/users.kct /path/to/session.kct</pre>

<p>The users database can be referred to as {database, "users.kct"} or
{database, 0}. The session database is {database, 1} or {database,
"session.kct"}.</p>

<p> </p>

<p>The binary protocol only supports integer database identifcation, so
it might be useful to standardize on integer identification in any new
software that could potentially use both binary and HTTP based
protocol functions.</p>

<h4><a name="cursors">cursors</a></h4>

<p>Kyoto Tycoon implements a well-designed system for interacting with
its databases through cursors, which are a simple and stateful
abstraction for traversing and interacting with specific records
through a pointer.</p>

<p> </p>

<p>The interface is very easy to understand. First, the software obtains
a cursor through the use of the <a href="#cursor-1"><code>cursor/1</code></a> call. That cursor
then must to be positioned to a specific record in a database through
the use of jump calls such as <a href="#cur_jump-2"><code>cur_jump/2</code></a> or <a href="#cur_jump_back-2"><code>cur_jump_back/2</code></a>. Those calls are documented in greater detail below.</p>

<p> </p>

<p>One simple but important nuance of the cursor interface is the
difference between the cur_jump and cur_jump_back calls. They both
support the ability to jump to a specific record located by its key,
or separately, they can jump to the first or last record in a
database. The important difference is the jump method influences all
subsequent automatic cursor stepping operations.</p>

<p> </p>

<p>As an example, the <a href="#cur_get-2"><code>cur_get/2</code></a> function retrieves the key and
value of a record the cursor points to. It has a boolean 'step'
parameter, which if true, instructs Kyoto Tycoon to move the cursor to
an adjacent record after the cursor's record is accessed. If the
cursor was initially positioned with a cur_jump_back call, the cursor
will move (or 'step') towards the start of the database.  If the
cursor was positioned with a cur_jump call, the cursor will step
towards the end of the database.</p>

<p> </p>

<p>This functionality is useful if the software needs to iterate through
the entire database (or a subset from a specific starting key.) Simply
jump to a starting position using cur_jump to iterate in forward key
order, or cur_jump_back for reverse key order. Then repeatedly invoke
an automatic stepping call such as <a href="#cur_get_key-2"><code>cur_get_key/2</code></a> until it
returns {error,invalid_cursor}. At that point, the database contains
no additional records for the cursor to step to.</p>

<p> </p>

<p>A cursor has been invalidated by the server when a cursor call returns
{error,invalid_cursor}. When this occurs, the cursor is unusable until
it's repositioned with a jump call.</p>

<p> </p>

<p>On final note: Cursor traversal order is dependent on the database's
type. For tree databases, it is ordered by key, and for hash
databases, by a hashing function. Hash type databases possibly will
not support cur_step_back calls.</p>

<h4><a name="signals">signals</a></h4>

<p>Kyoto Tycoon provides to its clients an ability to synchronize work
through the use of signals. Clients can wait for a named signal before
performing a database operation, and/or broadcast a signal to one or
more waiting clients after a database operation is finished.</p>

<p>kterl exposes this functionality throughout. The relevant call
parameters are:</p>

<pre>{wait, "signalname"}      Forces the client to block until it receives "signalname".


{waittime, NSeconds}      Optional timeout parameter for 'wait', in seconds. If the signal isn't
                          received within this period, the database operation isn't performed 
                          and the function returns {error,timed_out}. The default value is 30 seconds.


{signal, "signalname"}    The client will send "signalname" to one or all clients after its
                          database operation is complete.


{signalbroad, boolean()}  Optional 'signal' parameter. If set to true, all clients waiting on
                          "signalname" will receive the signal. Otherwise, it will be received
                          by the first client to enter a wait state. This default value is false.</pre>

<p>kterl calls that are passed a 'signal' parameter will return a count
of the number of clients that received the signal. This value is
accessed by <a href="kterl_result.html#get_signaled_count-1"><code>kterl_result:get_signaled_count/1</code></a>.</p>


<p>The Kyoto Tycoon documentation warns that a call waiting on a signal
occupies a thread, and that it should be used only for monitoring
records by a few clients.</p>

<h4><a name="record_expiration">record expiration</a></h4>

<p>Kyoto Tycoon has the ability to automatically expire records. kterl
provides the ability to set an expiration time by using the 'xt'
parameter on all supported calls, such as <a href="#set-4"><code>set/4</code></a>, <a href="#add-4"><code>add/4</code></a>, <a href="#replace-4"><code>replace/4</code></a>. The binary protocol <a href="#bin_set_bulk-2"><code>bin_set_bulk/2</code></a>
also supports setting an expiration time.</p>

<p> </p>

<p>The 'xt' parameter accepts two possible values to set an expiration
time: An integer for the number of seconds the record should exist, or
an Erlang <a href="http://www.erlang.org/doc/man/calendar.html">calendar:datetime()</a>
value to set an absolute date and time. kterl handles this conversion
automatically.</p>

<p> </p>



<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-kt_bin_kv">kt_bin_kv()</a></h3>
<p><tt>kt_bin_kv() = {Key::binary(), Value::binary()}</tt></p>


<h3 class="typedecl"><a name="type-kt_bin_kv_list">kt_bin_kv_list()</a></h3>
<p><tt>kt_bin_kv_list() = [<a href="#type-kt_bin_kv">kt_bin_kv()</a>]</tt></p>


<h3 class="typedecl"><a name="type-kt_bin_rec">kt_bin_rec()</a></h3>
<p><tt>kt_bin_rec() = #kt_bin_rec{dbidx = non_neg_integer(), xt = non_neg_integer(), key = binary(), val = binary()}</tt></p>


<h3 class="typedecl"><a name="type-kt_call_kvl">kt_call_kvl()</a></h3>
<p><tt>kt_call_kvl() = <a href="#type-kt_kv_list">kt_kv_list()</a> | <a href="dict.html#type-dict">dict:dict()</a></tt></p>


<h3 class="typedecl"><a name="type-kt_client">kt_client()</a></h3>
<p><tt>kt_client() = pid()</tt></p>


<h3 class="typedecl"><a name="type-kt_cursor">kt_cursor()</a></h3>
<p><tt>kt_cursor() = #kterl_cursor{cursor_id = non_neg_integer(), client_pid = pid()}</tt></p>


<h3 class="typedecl"><a name="type-kt_database">kt_database()</a></h3>
<p><tt>kt_database() = non_neg_integer() | string() | binary()</tt></p>


<h3 class="typedecl"><a name="type-kt_exptime">kt_exptime()</a></h3>
<p><tt>kt_exptime() = non_neg_integer() | <a href="calendar.html#type-datetime">calendar:datetime()</a></tt></p>


<h3 class="typedecl"><a name="type-kt_http_error">kt_http_error()</a></h3>
<p><tt>kt_http_error() = {error, {http_result, StatusCode::<a href="#type-kt_http_status">kt_http_status()</a>, Err::binary() | term()}}</tt></p>


<h3 class="typedecl"><a name="type-kt_http_result">kt_http_result()</a></h3>
<p><tt>kt_http_result() = #kt_http_result{key = binary(), value = binary(), exptime = non_neg_integer(), signaled_count = non_neg_integer(), num = number(), keys = [binary()], bulk_records = [{Key::binary(), Value::binary()}]}</tt></p>


<h3 class="typedecl"><a name="type-kt_http_status">kt_http_status()</a></h3>
<p><tt>kt_http_status() = 200 | 400 | 450 | 500 | 501 | 503</tt></p>


<h3 class="typedecl"><a name="type-kt_key">kt_key()</a></h3>
<p><tt>kt_key() = <a href="#type-kt_str">kt_str()</a></tt></p>


<h3 class="typedecl"><a name="type-kt_key_list">kt_key_list()</a></h3>
<p><tt>kt_key_list() = [<a href="#type-kt_key">kt_key()</a>]</tt></p>


<h3 class="typedecl"><a name="type-kt_kv">kt_kv()</a></h3>
<p><tt>kt_kv() = {<a href="#type-kt_key">kt_key()</a>, <a href="#type-kt_value">kt_value()</a>}</tt></p>


<h3 class="typedecl"><a name="type-kt_kv_list">kt_kv_list()</a></h3>
<p><tt>kt_kv_list() = [<a href="#type-kt_kv">kt_kv()</a>]</tt></p>


<h3 class="typedecl"><a name="type-kt_optargs">kt_optargs()</a></h3>
<p><tt>kt_optargs() = [{atom(), atom() | number() | string() | binary() | <a href="#type-kt_exptime">kt_exptime()</a>}]</tt></p>


<h3 class="typedecl"><a name="type-kt_str">kt_str()</a></h3>
<p><tt>kt_str() = string() | binary()</tt></p>


<h3 class="typedecl"><a name="type-kt_value">kt_value()</a></h3>
<p><tt>kt_value() = <a href="#type-kt_str">kt_str()</a> | number() | atom()</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add-2">add/2</a></td><td>Calls /rpc/add.</td></tr>
<tr><td valign="top"><a href="#add-3">add/3</a></td><td>Calls /rpc/add.</td></tr>
<tr><td valign="top"><a href="#add-4">add/4</a></td><td>Calls /rpc/add.</td></tr>
<tr><td valign="top"><a href="#append-3">append/3</a></td><td>
Calls /rpc/append.</td></tr>
<tr><td valign="top"><a href="#append-4">append/4</a></td><td>
Calls /rpc/append.</td></tr>
<tr><td valign="top"><a href="#bin_get_bulk-2">bin_get_bulk/2</a></td><td>Retrieves multiple records using the binary protocol.</td></tr>
<tr><td valign="top"><a href="#bin_play_script-3">bin_play_script/3</a></td><td><em>binary protocol:</em> Invokes a procedure of the script language extension.</td></tr>
<tr><td valign="top"><a href="#bin_remove_bulk-2">bin_remove_bulk/2</a></td><td><em>binary protocol:</em> Removes multiple records at once.</td></tr>
<tr><td valign="top"><a href="#bin_set_bulk-2">bin_set_bulk/2</a></td><td><em>binary protocol:</em> Stores multiple k,v pairs at once.</td></tr>
<tr><td valign="top"><a href="#cas-3">cas/3</a></td><td>
Calls /rpc/cas.</td></tr>
<tr><td valign="top"><a href="#cas-4">cas/4</a></td><td>
Calls /rpc/cas.</td></tr>
<tr><td valign="top"><a href="#clear-1">clear/1</a></td><td>Calls /rpc/clear.</td></tr>
<tr><td valign="top"><a href="#clear-2">clear/2</a></td><td>Calls /rpc/clear.</td></tr>
<tr><td valign="top"><a href="#configure-2">configure/2</a></td><td>Configures the connection handler.</td></tr>
<tr><td valign="top"><a href="#connect-1">connect/1</a></td><td>Connects to [{host, Host}, {port, Port}].</td></tr>
<tr><td valign="top"><a href="#connect-3">connect/3</a></td><td>Connects to Host, Port, with ReconnectSleep retry interval.</td></tr>
<tr><td valign="top"><a href="#cur_get-1">cur_get/1</a></td><td>
Calls /rpc/cur_get.</td></tr>
<tr><td valign="top"><a href="#cur_get-2">cur_get/2</a></td><td>
Calls /rpc/cur_get.</td></tr>
<tr><td valign="top"><a href="#cur_get-3">cur_get/3</a></td><td>
Calls /rpc/cur_get.</td></tr>
<tr><td valign="top"><a href="#cur_get_key-1">cur_get_key/1</a></td><td>
Calls /rpc/cur_get_key.</td></tr>
<tr><td valign="top"><a href="#cur_get_key-2">cur_get_key/2</a></td><td>
Calls /rpc/cur_get_key.</td></tr>
<tr><td valign="top"><a href="#cur_get_key-3">cur_get_key/3</a></td><td>
Calls /rpc/cur_get_key.</td></tr>
<tr><td valign="top"><a href="#cur_get_value-1">cur_get_value/1</a></td><td>
Calls /rpc/cur_get_value.</td></tr>
<tr><td valign="top"><a href="#cur_get_value-2">cur_get_value/2</a></td><td>
Calls /rpc/cur_get_value.</td></tr>
<tr><td valign="top"><a href="#cur_get_value-3">cur_get_value/3</a></td><td>
Calls /rpc/cur_get_value.</td></tr>
<tr><td valign="top"><a href="#cur_jump-1">cur_jump/1</a></td><td>
Calls /rpc/cur_jump.</td></tr>
<tr><td valign="top"><a href="#cur_jump-2">cur_jump/2</a></td><td>
Calls /rpc/cur_jump.</td></tr>
<tr><td valign="top"><a href="#cur_jump_back-1">cur_jump_back/1</a></td><td>
Calls /rpc/cur_jump_back.</td></tr>
<tr><td valign="top"><a href="#cur_jump_back-2">cur_jump_back/2</a></td><td>
Calls /rpc/cur_jump_back.</td></tr>
<tr><td valign="top"><a href="#cur_jump_back_opt-2">cur_jump_back_opt/2</a></td><td>
Calls /rpc/cur_jump_back.</td></tr>
<tr><td valign="top"><a href="#cur_jump_opt-2">cur_jump_opt/2</a></td><td>
Calls /rpc/cur_jump.</td></tr>
<tr><td valign="top"><a href="#cur_remove-1">cur_remove/1</a></td><td>
Calls /rpc/cur_remove.</td></tr>
<tr><td valign="top"><a href="#cur_remove-2">cur_remove/2</a></td><td>
Calls /rpc/cur_remove.</td></tr>
<tr><td valign="top"><a href="#cur_seize-1">cur_seize/1</a></td><td>
Calls /rpc/cur_seize.</td></tr>
<tr><td valign="top"><a href="#cur_seize-2">cur_seize/2</a></td><td>
Calls /rpc/cur_seize.</td></tr>
<tr><td valign="top"><a href="#cur_set_value-2">cur_set_value/2</a></td><td>
Calls /rpc/cur_set_value.</td></tr>
<tr><td valign="top"><a href="#cur_set_value-3">cur_set_value/3</a></td><td>
Calls /rpc/cur_set_value.</td></tr>
<tr><td valign="top"><a href="#cur_set_value_opt-2">cur_set_value_opt/2</a></td><td>
Calls /rpc/cur_set_value.</td></tr>
<tr><td valign="top"><a href="#cur_step-1">cur_step/1</a></td><td>
Calls /rpc/cur_step.</td></tr>
<tr><td valign="top"><a href="#cur_step-2">cur_step/2</a></td><td>
Calls /rpc/cur_step.</td></tr>
<tr><td valign="top"><a href="#cur_step_back-1">cur_step_back/1</a></td><td>
Calls /rpc/cur_step_back.</td></tr>
<tr><td valign="top"><a href="#cur_step_back-2">cur_step_back/2</a></td><td>
Calls /rpc/cur_step_back.</td></tr>
<tr><td valign="top"><a href="#cursor-1">cursor/1</a></td><td>

Returns a cursor handle for all subsequent cur_* calls.</td></tr>
<tr><td valign="top"><a href="#echo-2">echo/2</a></td><td>Calls /rpc/echo.</td></tr>
<tr><td valign="top"><a href="#garbage_collect-1">garbage_collect/1</a></td><td>Forces the connection handler to perform garbage collection.</td></tr>
<tr><td valign="top"><a href="#get-2">get/2</a></td><td>
Calls /rpc/get.</td></tr>
<tr><td valign="top"><a href="#get-3">get/3</a></td><td>
Calls /rpc/get.</td></tr>
<tr><td valign="top"><a href="#get_bulk-2">get_bulk/2</a></td><td>

Calls /rpc/get_bulk.</td></tr>
<tr><td valign="top"><a href="#get_bulk-3">get_bulk/3</a></td><td>

Calls /rpc/get_bulk.</td></tr>
<tr><td valign="top"><a href="#increment-3">increment/3</a></td><td>
Calls /rpc/increment.</td></tr>
<tr><td valign="top"><a href="#increment-4">increment/4</a></td><td>
Calls /rpc/increment.</td></tr>
<tr><td valign="top"><a href="#increment_double-3">increment_double/3</a></td><td>
Calls /rpc/increment_double.</td></tr>
<tr><td valign="top"><a href="#increment_double-4">increment_double/4</a></td><td>
Calls /rpc/increment_double.</td></tr>
<tr><td valign="top"><a href="#local_stats-1">local_stats/1</a></td><td>Returns stats maintained by the local connection handler.</td></tr>
<tr><td valign="top"><a href="#match_prefix-2">match_prefix/2</a></td><td>
Calls /rpc/match_prefix.</td></tr>
<tr><td valign="top"><a href="#match_prefix-3">match_prefix/3</a></td><td>
Calls /rpc/match_prefix.</td></tr>
<tr><td valign="top"><a href="#match_regex-2">match_regex/2</a></td><td>
Calls /rpc/match_regex.</td></tr>
<tr><td valign="top"><a href="#match_regex-3">match_regex/3</a></td><td>
Calls /rpc/match_regex.</td></tr>
<tr><td valign="top"><a href="#play_script-2">play_script/2</a></td><td>Calls /rpc/play_script.</td></tr>
<tr><td valign="top"><a href="#play_script-3">play_script/3</a></td><td>Calls /rpc/play_script.</td></tr>
<tr><td valign="top"><a href="#play_script-4">play_script/4</a></td><td>Calls /rpc/play_script.</td></tr>
<tr><td valign="top"><a href="#release_cursor-1">release_cursor/1</a></td><td>
Release the cursor by invoking /rpc/cur_delete.</td></tr>
<tr><td valign="top"><a href="#remove-2">remove/2</a></td><td>
Calls /rpc/remove.</td></tr>
<tr><td valign="top"><a href="#remove-3">remove/3</a></td><td>
Calls /rpc/remove.</td></tr>
<tr><td valign="top"><a href="#remove_bulk-2">remove_bulk/2</a></td><td>

Calls /rpc/remove_bulk.</td></tr>
<tr><td valign="top"><a href="#remove_bulk-3">remove_bulk/3</a></td><td>

Calls /rpc/remove_bulk.</td></tr>
<tr><td valign="top"><a href="#replace-2">replace/2</a></td><td>Calls /rpc/replace.</td></tr>
<tr><td valign="top"><a href="#replace-3">replace/3</a></td><td>Calls /rpc/replace.</td></tr>
<tr><td valign="top"><a href="#replace-4">replace/4</a></td><td>Calls /rpc/replace.</td></tr>
<tr><td valign="top"><a href="#report-1">report/1</a></td><td>Calls /rpc/report.</td></tr>
<tr><td valign="top"><a href="#seize-2">seize/2</a></td><td>

Calls /rpc/seize.</td></tr>
<tr><td valign="top"><a href="#seize-3">seize/3</a></td><td>

Calls /rpc/seize.</td></tr>
<tr><td valign="top"><a href="#set-2">set/2</a></td><td>Calls /rpc/set.</td></tr>
<tr><td valign="top"><a href="#set-3">set/3</a></td><td>
Calls /rpc/set.</td></tr>
<tr><td valign="top"><a href="#set-4">set/4</a></td><td>
Calls /rpc/set.</td></tr>
<tr><td valign="top"><a href="#set_bulk-2">set_bulk/2</a></td><td>

Calls /rpc/set_bulk.</td></tr>
<tr><td valign="top"><a href="#set_bulk-3">set_bulk/3</a></td><td>

Calls /rpc/set_bulk.</td></tr>
<tr><td valign="top"><a href="#start_link-0">start_link/0</a></td><td>Connects to database @ localhost:1978 with a 5 second connection
  retry interval.</td></tr>
<tr><td valign="top"><a href="#start_link-1">start_link/1</a></td><td>Connects to 'host' on port number 'port'
  with a connection retry interval of 'reconnect_sleep' ms.</td></tr>
<tr><td valign="top"><a href="#start_link-3">start_link/3</a></td><td>Connects to Host : Port with a connection retry interval of
  ReconnectSleep ms.</td></tr>
<tr><td valign="top"><a href="#status-1">status/1</a></td><td>Calls /rpc/status.</td></tr>
<tr><td valign="top"><a href="#status-2">status/2</a></td><td>Calls /rpc/status.</td></tr>
<tr><td valign="top"><a href="#stop-1">stop/1</a></td><td>Gracefully closes the tcp connection and stops the gen_server
  connection handler.</td></tr>
<tr><td valign="top"><a href="#synchronize-1">synchronize/1</a></td><td>Calls /rpc/synchronize.</td></tr>
<tr><td valign="top"><a href="#synchronize-2">synchronize/2</a></td><td>Calls /rpc/synchronize.</td></tr>
<tr><td valign="top"><a href="#tune_replication-2">tune_replication/2</a></td><td>Calls /rpc/tune_replication.</td></tr>
<tr><td valign="top"><a href="#vacuum-1">vacuum/1</a></td><td>

Calls /rpc/vacuum.</td></tr>
<tr><td valign="top"><a href="#vacuum-2">vacuum/2</a></td><td>

Calls /rpc/vacuum.</td></tr>
<tr><td valign="top"><a href="#void-1">void/1</a></td><td>Calls /rpc/void.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="add-2">add/2</a></h3>
<div class="spec">
<p><tt>add(Client::<a href="#type-kt_client">kt_client()</a>, KeyValue::{Key::<a href="#type-kt_key">kt_key()</a>, Value::<a href="#type-kt_value">kt_value()</a>}) -&gt; ok | {error, duplicate_key} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/add<p> </p>

<p>Adds a new record to the primary database.</p>

<pre>% example:

add_new_record(Pid, Record = {Key, _Value}) -&gt;
    case kterl:add(Pid, Record) of
         ok -&gt; 
             ok;
         {error, duplicate_key} -&gt; 
             throw({duplicate_key, Key})
end.</pre>
<p> </p>On success add/2 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#add-3">add/3</a>, <a href="#add-4">add/4</a>.</p>

<h3 class="function"><a name="add-3">add/3</a></h3>
<div class="spec">
<p><tt>add(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, Value::<a href="#type-kt_value">kt_value()</a>) -&gt; ok | {error, duplicate_key} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/add<p> </p>
Adds a new record to the primary database.
<pre>% example:

1&gt; ok = kterl:add(Pid, &lt;&lt;"key"&gt;&gt;, &lt;&lt;"value"&gt;&gt;).
ok
2&gt; kterl:add(Pid, &lt;&lt;"key"&gt;&gt;, &lt;&lt;"value"&gt;&gt;).
{error, duplicate_key}</pre>
<p> </p>On success add/3 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#add-2">add/2</a>, <a href="#add-4">add/4</a>.</p>

<h3 class="function"><a name="add-4">add/4</a></h3>
<div class="spec">
<p><tt>add(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, Value::<a href="#type-kt_value">kt_value()</a>, OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {xt, <a href="#type-kt_exptime">kt_exptime()</a>} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, duplicate_key} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p><p>Calls /rpc/add<br></p>

<p>Adds a new record to a specified database. This is the function to
call to set an expiration time, signal/wait parameters, or to specify
which database the record will be added to.</p>

<pre>% example: waits for an "goahead" signal for 30 seconds, and then adds
% a new record to the primary database. The call fails if it doesn't receive
% the signal within the waittime setting.

add_status_record(Pid, Key, Value) -&gt;
    case kterl:add(Pid, Key, Value, [{wait, "goahead"}, {waittime, 30}]) of
        {ok, _} -&gt; 
            ok;
        {error, Why} when Why =:= duplicate_key; Why =:= timed_out -&gt;
            throw({error, {add_status, Why, Key}})
end.</pre>
<p> </p>On success add/4 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#add-2">add/2</a>, <a href="#add-3">add/3</a>.</p>

<h3 class="function"><a name="append-3">append/3</a></h3>
<div class="spec">
<p><tt>append(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, Value::<a href="#type-kt_value">kt_value()</a>) -&gt; ok | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/append<p> </p>

<p>Appends a value to a record. The record is created if it doesn't exist.</p>

<pre>% example:

1&gt; ok = kterl:set(Pid, "key", "this is").
ok
2&gt; {ok, Res} = kterl:get(Pid, "key").
...
3&gt; kterl_result:get_value(Res).
&lt;&lt;"this is"&gt;&gt;
4&gt; ok = kterl:append(Pid, "key", " a test.").
ok
5&gt; kterl_result:get_value(kterl:get(Pid, "key"))
&lt;&lt;"this is a test"&gt;&gt;</pre>
<p> </p>On success append/3 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#append-4">append/4</a>.</p>

<h3 class="function"><a name="append-4">append/4</a></h3>
<div class="spec">
<p><tt>append(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, Value::<a href="#type-kt_value">kt_value()</a>, OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {xt, <a href="#type-kt_exptime">kt_exptime()</a>} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/append<p> </p>

<p>Appends a value to a record. The record is created if it doesn't exist.</p>

<pre>% example: This appends a tag to a user's set of tags, and then sends a 
% "username_tag" signal to any processes waiting for that signal.
% It returns {ok, N} where N is the number of clients that received the
% signal.

update_user_tags(Pid, Username, Tag) -&gt;
    {ok,Res} = kterl:append(Pid, Username, [$| | Tag],
                            [{database, "tags.kct"},
                             {signal, Username ++ "_" ++ Tag},
                             {signalbroad, true}]),
    {ok, kterl_result:get_signal_count(Res)}.</pre>
<p> </p>On success append/4 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#append-3">append/3</a>.</p>

<h3 class="function"><a name="bin_get_bulk-2">bin_get_bulk/2</a></h3>
<div class="spec">
<p><tt>bin_get_bulk(Client::<a href="#type-kt_client">kt_client()</a>, Keys::<a href="#type-kt_key_list">kt_key_list()</a> | {Key::<a href="#type-kt_key">kt_key()</a>, Database::non_neg_integer()}) -&gt; {ok, [<a href="#type-kt_bin_rec">kt_bin_rec()</a>]} | {error, term()}</tt><br></p>
</div><p>Retrieves multiple records using the binary protocol.</p>
<p><b>See also:</b> <a href="#get_bulk-2">get_bulk/2</a>, <a href="#get_bulk-3">get_bulk/3</a>.</p>

<h3 class="function"><a name="bin_play_script-3">bin_play_script/3</a></h3>
<div class="spec">
<p><tt>bin_play_script(Client::<a href="#type-kt_client">kt_client()</a>, Script::<a href="#type-kt_str">kt_str()</a>, KVL::<a href="dict.html#type-dict">dict:dict()</a> | <a href="#type-kt_kv_list">kt_kv_list()</a>) -&gt; {ok, [<a href="#type-kt_bin_rec">kt_bin_rec()</a>]} | {error, term()}</tt><br></p>
</div><p><em>binary protocol:</em> Invokes a procedure of the script language extension.</p>
<p><b>See also:</b> <a href="#play_script-2">play_script/2</a>, <a href="#play_script-3">play_script/3</a>.</p>

<h3 class="function"><a name="bin_remove_bulk-2">bin_remove_bulk/2</a></h3>
<div class="spec">
<p><tt>bin_remove_bulk(Client::<a href="#type-kt_client">kt_client()</a>, Keys::<a href="#type-kt_key_list">kt_key_list()</a> | {Key::<a href="#type-kt_key">kt_key()</a>, Database::non_neg_integer()}) -&gt; {ok, RecsDeleted::non_neg_integer()} | {error, term()}</tt><br></p>
</div><p><em>binary protocol:</em> Removes multiple records at once. Returns the number of
  record deletions performed.</p>
<p><b>See also:</b> <a href="#remove_bulk-2">remove_bulk/2</a>, <a href="#remove_bulk-3">remove_bulk/3</a>.</p>

<h3 class="function"><a name="bin_set_bulk-2">bin_set_bulk/2</a></h3>
<div class="spec">
<p><tt>bin_set_bulk(Client::<a href="#type-kt_client">kt_client()</a>, Recs::[#kt_bin_rec{dbidx = non_neg_integer(), xt = non_neg_integer(), key = binary(), val = binary()} | {Key::<a href="#type-kt_str">kt_str()</a>, Value::<a href="#type-kt_str">kt_str()</a>} | {Key::<a href="#type-kt_str">kt_str()</a>, Value::<a href="#type-kt_str">kt_str()</a>, Database::non_neg_integer()} | {Key::<a href="#type-kt_str">kt_str()</a>, Value::<a href="#type-kt_str">kt_str()</a>, Database::non_neg_integer(), ExpTime::<a href="#type-kt_exptime">kt_exptime()</a>}]) -&gt; {ok, RecordsCreated::non_neg_integer()} | {error, term()}</tt><br></p>
</div><p><em>binary protocol:</em> Stores multiple k,v pairs at once. Returns the number of records
  added.</p>
<p><b>See also:</b> <a href="#set_bulk-2">set_bulk/2</a>, <a href="#set_bulk-3">set_bulk/3</a>.</p>

<h3 class="function"><a name="cas-3">cas/3</a></h3>
<div class="spec">
<p><tt>cas(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {oval, <a href="#type-kt_value">kt_value()</a>} | {nval, <a href="#type-kt_value">kt_value()</a>} | {xt, <a href="#type-kt_exptime">kt_exptime()</a>} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, expired_value} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cas<p> </p>
Depending on the parameters, this function can perform an atomic value
compare-and-swap, a record add, or an atomic record compare-and-remove
operation.
<p> </p><p>
The functionality is controlled by two optional proplists parameters:
<code>'oval'</code>, for the record's old value, and <code>'nval'</code> 
for the new. If <code>'oval'</code> is omitted, a new record is added with 
<code>'nval'</code> as the value. If <code>'nval'</code> is omitted, but 
<code>'oval'</code> matches the existing record's value, the
record is removed. </p>

<pre>1&gt; kterl_result:get_value(kterl:get(Pid, "cas_test")).
{error,no_record}
2&gt; {ok,_} = kterl:cas(Pid,"cas_test",[{nval,"testing"}]).
...
3&gt; kterl_result:get_value(kterl:get(Pid, "cas_test")).
&lt;&lt;"testing"&gt;&gt;
4&gt; kterl:cas(Pid,"cas_test",[{nval,"new value"}]).
{error,expired_value}
5&gt; {ok,_} = kterl:cas(Pid,"cas_test",[{oval,"testing"}, {nval,"1,2,3"}]).
...
6&gt; kterl_result:get_value(kterl:get(Pid, "cas_test")).
&lt;&lt;"1,2,3"&gt;&gt;
7&gt; kterl:cas(Pid,"cas_test",[{oval,"bogus value"}]).
{error,expired_value}
8&gt; {ok,_} = kterl:cas(Pid,"cas_test",[{oval,"1,2,3"}]).
...
9&gt; kterl:get(Pid,"cas_test").
{error,no_record}</pre>
<h4><a name="example">example</a></h4>
<pre>%%% updates the user's age in the users.kct database's user record.
update_user_age(Pid, User0 = #user{name = Username}, Age) -&gt;
    User1 = User0#user{age = Age},
    case kterl:cas(Pid, Username, 
                   [{database, "users.kct"},
                    {oval, user_record(User0)},
                    {nval, user_record(User1)}]) of
        {ok,_} -&gt; ok;
        Err = {error,expired_value} -&gt; throw(Err)
    end.

user_record(User = #user{}) -&gt; term_to_binary(User, [compressed]).</pre>   
<p> </p>On success cas/3 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#cas-4">cas/4</a>.</p>

<h3 class="function"><a name="cas-4">cas/4</a></h3>
<div class="spec">
<p><tt>cas(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, OldValue::<a href="#type-kt_value">kt_value()</a>, NewValue::<a href="#type-kt_value">kt_value()</a>) -&gt; ok | {error, expired_value} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cas<p> </p>

<p>Performs an atomic record value compare-and-swap. Updates the record's
old value. The call will fail if the key doesn't exist, or if the
value in the database does not match the OldValue.</p>

<pre>% example:

1&gt; kterl:get(Pid, "cas_test").
{error,no_record}.
2&gt; kterl:cas(Pid, "cas_test", "old value", "new value").
{error,expired_value}.
3&gt; ok = kterl:add(Pid, "cas_test", &lt;&lt;"old value"&gt;&gt;).
ok
4&gt; kterl_result:get_value(kterl:get(Pid, "cas_test")).
&lt;&lt;"old value"&gt;&gt;
5&gt; kterl:cas(Pid, "cas_test", "Bogus old value", "new value").
{error,expired_value}.
6&gt; ok = kterl:cas(Pid, "cas_test", "old value", "new value").
ok
7&gt; kterl_result:get_value(kterl:get(Pid, "cas_test")).
&lt;&lt;"new value"&gt;&gt;</pre>

<p> </p>On success cas/4 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#cas-3">cas/3</a>.</p>

<h3 class="function"><a name="clear-1">clear/1</a></h3>
<div class="spec">
<p><tt>clear(Client::<a href="#type-kt_client">kt_client()</a>) -&gt; ok | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/clear<p> </p>
Removes all records from the primary database.
<pre>% example:

clear_kt_database(Pid) -&gt;
    ok = kterl:clear(Pid).</pre>
<p> </p>On success clear/1 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#clear-2">clear/2</a>.</p>

<h3 class="function"><a name="clear-2">clear/2</a></h3>
<div class="spec">
<p><tt>clear(Client::<a href="#type-kt_client">kt_client()</a>, OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/clear<p> </p>
Removes all records from a specified database.
<pre>% example:

clear_kt_database(Pid, Database) -&gt;
    ok = kterl:clear(Pid, [{database, Database}]).

2&gt; clear_kt_database(Pid, 1).
ok
3&gt; clear_kt_database(Pid, "database.kct").
ok</pre>
<p> </p>On success clear/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#clear-1">clear/1</a>.</p>

<h3 class="function"><a name="configure-2">configure/2</a></h3>
<div class="spec">
<p><tt>configure(Client::<a href="#type-kt_client">kt_client()</a>, Conf::[{wire_dump, boolean()}]) -&gt; ok</tt><br></p>
</div><p>Configures the connection handler.<br>
  <code>{wire_dump, boolean()}</code> to send all wire traffic to error_logger
  (default: false)</p>

<h3 class="function"><a name="connect-1">connect/1</a></h3>
<div class="spec">
<p><tt>connect(Args::[{host, string()} | {port, <a href="inet.html#type-port_number">inet:port_number()</a>} | {reconnect_sleep, non_neg_integer()}]) -&gt; {ok, pid()} | {error, term()}</tt><br></p>
</div><p>Connects to [{host, Host}, {port, Port}].
  Attaches the connection worker pid to a supervisor. Requires that the
  kterl application is started.</p>

<h3 class="function"><a name="connect-3">connect/3</a></h3>
<div class="spec">
<p><tt>connect(Host::string(), Port::<a href="inet.html#type-port_number">inet:port_number()</a>, ReconnectSleep::non_neg_integer()) -&gt; {ok, pid()} | {error, term()}</tt><br></p>
</div><p>Connects to Host, Port, with ReconnectSleep retry interval.
  Attaches the connection worker pid to a supervisor. Requires that the
  kterl application is started.</p>

<h3 class="function"><a name="cur_get-1">cur_get/1</a></h3>
<div class="spec">
<p><tt>cur_get(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, invalid_cursor} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_get<p> </p>

<p>Retrieves the key and value, and if set, the expiration time of the
record located at the cursor. This function does not instruct the
server to 'step' the cursor to the next/previous record after the
call. For this, use <a href="#cur_get-2"><code>cur_get/2</code></a> or <a href="#cur_get-3"><code>cur_get/3</code></a>.</p>

<pre>% example:

1&gt; ok = kterl:add(Pid, "New_record", "Value!").
ok
2&gt; Cursor = kterl:cursor(Pid).
...
3&gt; ok = kterl:cur_jump(Cursor, [{key,"New_record"}]).
ok
4&gt; {ok, Res} = kterl:cur_get(Cursor).
...
5&gt; kterl_result:get_key(Res).
&lt;&lt;"New_record"&gt;&gt;
6&gt; kterl_result:get_value(Res).
&lt;&lt;"Value!"&gt;&gt;</pre>

<p> </p>On success cur_get/1 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_value(Result).           % The record's value.
kterl_result:get_key(Result).             % The record's key.
kterl_result:get_exptime(Result).         % The record's expiration time (if set.)</pre></p>
<p><b>See also:</b> <a href="#cur_get-2">cur_get/2</a>, <a href="#cur_get-3">cur_get/3</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_get-2">cur_get/2</a></h3>
<div class="spec">
<p><tt>cur_get(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, Step::boolean()) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, invalid_cursor} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_get<p> </p>

<p>Retrieves the key and value, and if set, the expiration time of the
record located at the cursor. If 'step' is set to true, the server
will reposition the cursor to an adjacent record after the key and
value are retrieved.</p>

<pre>% example:

1&gt; ok = kterl:clear(Pid).
ok
2&gt; kterl:set_bulk(Pid,[{"key1","val1"},{"key2","val2"},{"key3","val3"}]).
...
3&gt; Cursor = kterl:cursor(Pid).
...
4&gt; ok = kterl:cur_jump(Cursor, [{key,"key2"}]).
ok
5&gt; {ok, Res} = kterl:cur_get(Cursor, true).
...
6&gt; kterl_result:get_key(Res).
&lt;&lt;"key2"&gt;&gt;
7&gt; kterl_result:get_value(Res).
&lt;&lt;"val2"&gt;&gt;
8&gt; {ok, Res1} = kterl:cur_get(Cursor, true).
...
9&gt; kterl_result:get_key(Res1).
&lt;&lt;"key3"&gt;&gt;
10&gt; kterl_result:get_value(Res1).
&lt;&lt;"val3"&gt;&gt;
11&gt; {error,invalid_cursor} = kterl:cur_get(Cursor, true).
{error,invalid_cursor}</pre>

<p> </p>On success cur_get/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_value(Result).           % The record's value.
kterl_result:get_key(Result).             % The record's key.
kterl_result:get_exptime(Result).         % The record's expiration time (if set.)</pre></p>
<p><b>See also:</b> <a href="#cur_get-1">cur_get/1</a>, <a href="#cur_get-3">cur_get/3</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_get-3">cur_get/3</a></h3>
<div class="spec">
<p><tt>cur_get(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, Step::boolean(), OptArgs::[{wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, invalid_cursor} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_get<p> </p>

<p>Retrieves the key and value, and if set, the expiration time of the
record located at the cursor. If step is true, the server will
reposition the cursor to an adjacent record after the key and value
are retrieved. This function cal also interact with the server's
wait/signal mechanism.</p>

<p> </p>On success cur_get/3 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_value(Result).           % The record's value.
kterl_result:get_key(Result).             % The record's key.
kterl_result:get_exptime(Result).         % The record's expiration time (if set.)
kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#cur_get-1">cur_get/1</a>, <a href="#cur_get-2">cur_get/2</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_get_key-1">cur_get_key/1</a></h3>
<div class="spec">
<p><tt>cur_get_key(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, invalid_cursor} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_get_key<p> </p>

<p>Retrieves the key of the record located at the cursor. This function
does not instruct the server to 'step' the cursor to the next/previous
record after the call. For this, use <a href="#cur_get_key-2"><code>cur_get_key/2</code></a> or <a href="#cur_get_key-3"><code>cur_get_key/3</code></a>.</p>

<pre>% example:

1&gt; kterl:set_bulk(Pid,[{"key1","val1"},{"key2","val2"},{"key3","val3"}]).
...
2&gt; Cursor = kterl:cursor(Pid).
...
3&gt; ok = kterl:cur_jump(Cursor).
ok
4&gt; {ok, Res} = kterl:cur_get_key(Cursor).
{ok, ...}
5&gt; kterl_result:get_key(Res).
&lt;&lt;"key1"&gt;&gt;
6&gt; ok = kterl:cur_step(Cursor).
ok
7&gt; kterl_result:get_key(kterl:cur_get_key(Cursor)).
&lt;&lt;"key2"&gt;&gt;</pre>

<p> </p>On success cur_get_key/1 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_key(Result).             % The record's key.</pre></p>
<p><b>See also:</b> <a href="#cur_get_key-2">cur_get_key/2</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_get_key-2">cur_get_key/2</a></h3>
<div class="spec">
<p><tt>cur_get_key(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, Step::boolean()) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, invalid_cursor} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_get_key<p> </p>

<p>Retrieves the key of the record located at the cursor. If 'step' is
set to true, the server will reposition the cursor to an adjacent
record after the key is retrieved.</p>

<pre>% example:

1&gt; kterl:set_bulk(Pid,[{"key1","val1"},{"key2","val2"},{"key3","val3"}]).
...
2&gt; Cursor = kterl:cursor(Pid).
...
3&gt; ok = kterl:cur_jump(Cursor).
ok
4&gt; {ok, Res} = kterl:cur_get_key(Cursor, true).
{ok, ...}
5&gt; kterl_result:get_key(Res).
&lt;&lt;"key1"&gt;&gt;
6&gt; kterl_result:get_key(kterl:cur_get_key(Cursor, true)).
&lt;&lt;"key2"&gt;&gt;
6&gt; ok = kterl:cur_jump_back(Cursor).
ok
7&gt; kterl_result:get_key(kterl:cur_get_key(Cursor, true)).
&lt;&lt;"key3"&gt;&gt;
8&gt; kterl_result:get_key(kterl:cur_get_key(Cursor, true)).
&lt;&lt;"key2"&gt;&gt;
9&gt; kterl_result:get_key(kterl:cur_get_key(Cursor, true)).
&lt;&lt;"key1"&gt;&gt;
10&gt; kterl_result:get_key(kterl:cur_get_key(Cursor, true)).
{error,invalid_cursor}</pre>
<p> </p>On success cur_get_key/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_key(Result).             % The record's key.</pre></p>
<p><b>See also:</b> <a href="#cur_get_key-1">cur_get_key/1</a>, <a href="#cur_get_key-3">cur_get_key/3</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_get_key-3">cur_get_key/3</a></h3>
<div class="spec">
<p><tt>cur_get_key(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, Step::boolean(), OptArgs::[{wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, invalid_cursor} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_get_key<p> </p>

<p>Retrieves the key of the record located at the cursor. If step is
true, the server will reposition the cursor to an adjacent record
after the key is retrieved. This function can also interact with the
server's wait/signal mechanism.</p>

<p> </p>On success cur_get_key/3 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_key(Result).             % The record's key.
kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#cur_get_key-1">cur_get_key/1</a>, <a href="#cur_get_key-2">cur_get_key/2</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_get_value-1">cur_get_value/1</a></h3>
<div class="spec">
<p><tt>cur_get_value(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, invalid_cursor} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_get_value<p> </p>

<p>Retrieves the value of the record located at the cursor. This function
does not instruct the server to 'step' the cursor to the next/previous
record after the call. For this, use <a href="#cur_get_value-2"><code>cur_get_value/2</code></a> or <a href="#cur_get_value-3"><code>cur_get_value/3</code></a>.</p>

<pre>% example:

1&gt; ok = kterl:clear(Pid).
ok
2&gt; ok = kterl:add(Pid, &lt;&lt;"key"&gt;&gt;, &lt;&lt;"value"&gt;&gt;).
ok
3&gt; Cursor = kterl:cursor(Pid).
...
4&gt; ok = kterl:cur_jump(Cursor).
ok
5&gt; kterl_result:get_value(kterl:cur_get_value(Cursor)).
&lt;&lt;"value"&gt;&gt;
6&gt; kterl_result:get_key(kterl:cur_get_key(Cursor)).
&lt;&lt;"key"&gt;&gt;</pre>
<p> </p>On success cur_get_value/1 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_value(Result).           % The record's value.
kterl_result:get_exptime(Result).         % The record's expiration time (if set.)</pre></p>
<p><b>See also:</b> <a href="#cur_get_value-2">cur_get_value/2</a>, <a href="#cur_get_value-3">cur_get_value/3</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_get_value-2">cur_get_value/2</a></h3>
<div class="spec">
<p><tt>cur_get_value(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, Step::boolean()) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, invalid_cursor} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_get_value<p> </p>

<p>Retrieves the value of the record located at the cursor. If 'step' is true,
the server will reposition the cursor to an adjacent record after the value
is retrieved.</p>

<pre>% example:

1&gt; kterl:set_bulk(Pid, [{"key1","val1"}, {"key2","val2"}]).
...
2&gt; Cursor = kterl:cursor(Pid).
...
3&gt; ok = kterl:cur_jump(Cursor).
ok
4&gt; {ok, Res} = kterl:cur_get_value(Cursor, true).
{ok, ...}
5&gt; kterl_result:get_value(Res).
&lt;&lt;"val1"&gt;&gt;
6&gt; kterl_result:get_value(kterl:cur_get_value(Cursor, true)).
&lt;&lt;"val2"&gt;&gt;
7&gt; kterl_result:get_value(kterl:cur_get_value(Cursor, true)).
{error,invalid_cursor}</pre>

<p> </p>On success cur_get_value/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_value(Result).           % The record's value.
kterl_result:get_exptime(Result).         % The record's expiration time (if set.)</pre></p>
<p><b>See also:</b> <a href="#cur_get_value-1">cur_get_value/1</a>, <a href="#cur_get_value-3">cur_get_value/3</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_get_value-3">cur_get_value/3</a></h3>
<div class="spec">
<p><tt>cur_get_value(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, Step::boolean(), OptArgs::[{wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, invalid_cursor} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_get_value<p> </p>

<p>Retrieves the value of the record located at the cursor. If step is
true, the server will reposition the cursor to an adjacent record
after the value is retrieved. This function can also interact with the
server's wait/signal mechanism.</p>

<p> </p>On success cur_get_value/3 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_value(Result).           % The record's value.
kterl_result:get_exptime(Result).         % The record's expiration time (if set.)
kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#cur_get_value-1">cur_get_value/1</a>, <a href="#cur_get_value-2">cur_get_value/2</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_jump-1">cur_jump/1</a></h3>
<div class="spec">
<p><tt>cur_jump(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>) -&gt; ok | {error, invalid_cursor} | {error, not_implemented} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_jump<p> </p>

<p>Positions the cursor to the first record in the primary database.</p>

<p> </p>

<p>After this call, the cursor will be positioned to the <em>next</em>
record in all subsequent calls that automatically 'step' the cursor.</p>

<pre>% example:

1&gt; kterl:set_bulk(Pid,[{"key1","val1"},{"key2","val2"},{"key3","val3"}]).
...
2&gt; Cursor = kterl:cursor(Pid).
3&gt; kterl:cur_jump(Cursor).
ok
4&gt; kterl_result:get_key(kterl:cur_get_key(Cursor)).
&lt;&lt;"key1"&gt;&gt;</pre>
<p> </p>On success cur_jump/1 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#cur_jump-2">cur_jump/2</a>, <a href="#cur_jump_back-1">cur_jump_back/1</a>, <a href="#cur_jump_back-2">cur_jump_back/2</a>, <a href="#cur_jump_back_opt-2">cur_jump_back_opt/2</a>, <a href="#cur_jump_opt-2">cur_jump_opt/2</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_jump-2">cur_jump/2</a></h3>
<div class="spec">
<p><tt>cur_jump(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, KeyDatabase::[{key, <a href="#type-kt_key">kt_key()</a>} | {database, <a href="#type-kt_database">kt_database()</a>}]) -&gt; ok | {error, invalid_cursor | not_implemented} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_jump<p> </p>

<p>Positions the record in a database. This function accepts two optional
parameters: 'key' and 'database'. If 'key' is set, the cursor will be
positioned at that key; otherwise, it'll position the cursor to the
first record of a database. The 'database' parameter specifies the
target database. If it's not set, the server defaults to the primary
database.</p>

<p> </p>

<p>After this call, the cursor will be positioned to the <em>next</em>
record in all subsequent calls that automatically 'step' the cursor.</p>

<p> </p>

<p>To simplify the return status interface, this function does not
support the 'wait', 'waittime', 'signal', or 'signalbroad'
parameters. For these, use <a href="#cur_jump_opt-2"><code>cur_jump_opt/2</code></a>.</p>

<pre>% example:

1&gt; kterl:set_bulk(Pid,[{"key1","val1"},{"key2","val2"},{"key3","val3"}]).
...
2&gt; Cursor = kterl:cursor(Pid).
3&gt; kterl:cur_jump(Cursor,[{key, "key3"}]).
ok
4&gt; kterl_result:get_key(kterl:cur_get_key(Cursor)).
&lt;&lt;"key3"&gt;&gt;
5&gt; kterl:cur_jump(Cursor).
6&gt; kterl_result:get_key(kterl:cur_get_key(Cursor)).
&lt;&lt;"key1"&gt;&gt;</pre>
<p> </p>On success cur_jump/2 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#cur_jump-1">cur_jump/1</a>, <a href="#cur_jump_back-1">cur_jump_back/1</a>, <a href="#cur_jump_back-2">cur_jump_back/2</a>, <a href="#cur_jump_back_opt-2">cur_jump_back_opt/2</a>, <a href="#cur_jump_opt-2">cur_jump_opt/2</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_jump_back-1">cur_jump_back/1</a></h3>
<div class="spec">
<p><tt>cur_jump_back(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>) -&gt; ok | {error, invalid_cursor} | {error, not_implemented} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_jump_back<p> </p>

<p>Positions the cursor to the last record in the primary database.</p>

<p> </p>

<p>After this call, the cursor will be positioned to the
<em>previous</em> record in all subsequent calls that automatically
'step' the cursor.</p>

<pre>% example:

1&gt; kterl:set_bulk(Pid,[{"key1","val1"},{"key2","val2"},{"key3","val3"}]).
...
2&gt; Cursor = kterl:cursor(Pid).
3&gt; kterl:cur_jump_back(Cursor).
ok
4&gt; kterl_result:get_key(kterl:cur_get_key(Cursor)).
&lt;&lt;"key3"&gt;&gt;</pre>

<p> </p>On success cur_jump_back/1 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#cur_jump-1">cur_jump/1</a>, <a href="#cur_jump-2">cur_jump/2</a>, <a href="#cur_jump_back-2">cur_jump_back/2</a>, <a href="#cur_jump_back_opt-2">cur_jump_back_opt/2</a>, <a href="#cur_jump_opt-2">cur_jump_opt/2</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_jump_back-2">cur_jump_back/2</a></h3>
<div class="spec">
<p><tt>cur_jump_back(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, KeyDatabase::[{key, <a href="#type-kt_key">kt_key()</a>} | {database, <a href="#type-kt_database">kt_database()</a>}]) -&gt; ok | {error, invalid_cursor} | {error, not_implemented} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_jump_back<p> </p>

<p>Positions the record in a database. This function accepts two optional
parameters: 'key' and 'database'. If 'key' is set, the cursor will be
positioned at that key; otherwise, it'll position the cursor to the
last record of a database. The 'database' parameter specifies the
target database. If it's not set, the server defaults to the primary
database.</p>

<p> </p>

<p>After this call, the cursor will be positioned to the
<em>previous</em> record in all subsequent calls that automatically
'step' the cursor.</p>

<p> </p>

<p>To simplify the return status interface, this function does not
support the 'wait', 'waittime', 'signal', and 'signalbroad'
parameters. For these, use <a href="#cur_jump_back_opt-2"><code>cur_jump_back_opt/2</code></a>.</p>

<pre>% example:

1&gt; kterl:set_bulk(Pid,[{"key1","val1"},{"key2","val2"},{"key3","val3"}]).
...
2&gt; Cursor = kterl:cursor(Pid).
3&gt; ok = kterl:cur_jump_back(Cursor,[{key, "key2"}]).
ok
4&gt; kterl_result:get_key(kterl:cur_get_key(Cursor)).
&lt;&lt;"key2"&gt;&gt;
5&gt; kterl:cur_jump_back(Cursor).
ok
6&gt; kterl_result:get_key(kterl:cur_get_key(Cursor)).
&lt;&lt;"key3"&gt;&gt;</pre>
<p> </p>On success cur_jump_back/2 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#cur_jump-1">cur_jump/1</a>, <a href="#cur_jump-2">cur_jump/2</a>, <a href="#cur_jump_back-1">cur_jump_back/1</a>, <a href="#cur_jump_back_opt-2">cur_jump_back_opt/2</a>, <a href="#cur_jump_opt-2">cur_jump_opt/2</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_jump_back_opt-2">cur_jump_back_opt/2</a></h3>
<div class="spec">
<p><tt>cur_jump_back_opt(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, OptArgs::[{key, <a href="#type-kt_key">kt_key()</a>} | {database, <a href="#type-kt_database">kt_database()</a>} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, invalid_cursor} | {error, not_implemented} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_jump_back<p> </p>

<p>Positions the record in a database. Like <a href="#cur_jump_back-2"><code>cur_jump_back/2</code></a>, this
function accepts the optional 'key' and 'database' parameters. In
addition to these, this function accepts 'wait', 'waittime', 'signal',
and 'signalbroad' parameters, to interact with the signaling
mechanisms on the server.</p>

<p> </p>

<p>After this call, the cursor will be positioned to the
<em>previous</em> record in all subsequent calls that automatically
'step' the cursor.</p>

<p> </p>On success cur_jump_back_opt/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#cur_jump-1">cur_jump/1</a>, <a href="#cur_jump-2">cur_jump/2</a>, <a href="#cur_jump_back-1">cur_jump_back/1</a>, <a href="#cur_jump_back-2">cur_jump_back/2</a>, <a href="#cur_jump_opt-2">cur_jump_opt/2</a>.</p>

<h3 class="function"><a name="cur_jump_opt-2">cur_jump_opt/2</a></h3>
<div class="spec">
<p><tt>cur_jump_opt(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, OptArgs::[{key, <a href="#type-kt_key">kt_key()</a>} | {database, <a href="#type-kt_database">kt_database()</a>} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, not_implemented} | {error, invalid_cursor} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_jump<p> </p>

<p>Positions the cursor in a database. Like <a href="#cur_jump-2"><code>cur_jump/2</code></a>, this
function accepts the optional 'key' and 'database' parameters. In
addition to these, this function accepts 'wait', 'waittime', 'signal',
and 'signalbroad' parameters, to interact with the signaling
mechanisms on the server.</p>

<p> </p>

<p>After this call, the cursor will be positioned to the <em>next</em>
record in all subsequent calls that automatically 'step' the cursor.</p>


<p> </p>On success cur_jump_opt/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#cur_jump-1">cur_jump/1</a>, <a href="#cur_jump-2">cur_jump/2</a>, <a href="#cur_jump_back-1">cur_jump_back/1</a>, <a href="#cur_jump_back-2">cur_jump_back/2</a>, <a href="#cur_jump_back_opt-2">cur_jump_back_opt/2</a>.</p>

<h3 class="function"><a name="cur_remove-1">cur_remove/1</a></h3>
<div class="spec">
<p><tt>cur_remove(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>) -&gt; ok | {error, invalid_cursor} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_remove<p> </p>

<p>Removes the current record located at the cursor. The cursor is then
positioned to the next or previous record in the database, depending
on if the cursor was positioned with cur_step* or cur_step_back*
functions. </p>

<p> </p>

<p>If the last (or first) record in the database is removed or seized,
the cursor is invalidated for future operations until it's
repositioned with a jump call.</p>

<pre>% example:

1&gt; kterl:set_bulk(Pid,[{"key1","val1"},{"key2","val2"},{"key3","val3"}]).
...
2&gt; Cursor = kterl:cursor(Pid).
...
3&gt; ok = kterl:cur_jump(Cursor, [{key, "key2"}]).
ok
4&gt; ok = kterl:cur_remove(Cursor),
ok
5&gt; kterl_result:get_key(kterl:cur_get(Cursor)).
&lt;&lt;"key3"&gt;&gt;</pre>

<p> </p>On success cur_remove/1 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#cur_remove-2">cur_remove/2</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_remove-2">cur_remove/2</a></h3>
<div class="spec">
<p><tt>cur_remove(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, OptArgs::[{wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, invalid_cursor} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_remove<p> </p>

<p>Removes the current record located at the cursor. The cursor is then
positioned to the next or previous record in the database, depending
on if the cursor was positioned with cur_step* or cur_step_back*
functions.</p>

<p> </p>

<p>If the last (or first) record in the database is removed or seized,
the cursor is invalidated for future operations until it's
repositioned with a jump call.</p>

<p> </p>

<p>This function can interact with the server's signaling mechanism with
the optional 'wait', 'waittime', 'signal', and 'signalbroad'
parameters.</p>

<p> </p>On success cur_remove/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#cur_remove-1">cur_remove/1</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_seize-1">cur_seize/1</a></h3>
<div class="spec">
<p><tt>cur_seize(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, invalid_cursor} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_seize<p> </p>

<p>Returns the key, value, and if set, the expiration time of the record
located at the cursor. The record is then removed. If the last (or
first, depending on cur_jump/cur_jump_back step order) record is
removed or seized, the cursor is invalidated for future operations
until it's repositioned with a jump call.</p>

<pre>% example:

1&gt; ok = kterl:clear(Pid).
ok
2&gt; {ok,_} = kterl:set_bulk(Pid, [{"key1","val1"}, {"key2","val2"}, {"key3","val3"}]).
...
3&gt; Cursor = kterl:cursor(Pid).
...
4&gt; ok = kterl:cur_jump(Cursor, [{key,"key2"}]).
ok
5&gt; {ok,Res1} = kterl:cur_seize(Cursor).
...
6&gt; kterl:get_key(Res1).
&lt;&lt;"key2"&gt;&gt;
7&gt; kterl:get_value(Res1).
&lt;&lt;"val2"&gt;&gt;
8&gt; {ok, Res2} = kterl:cur_seize(Cursor).
...
9&gt; kterl:get_key(Res2).
&lt;&lt;"key3"&gt;&gt;
10&gt; kterl:get_value(Res2).
&lt;&lt;"key3"&gt;&gt;
11&gt; kterl:cur_get(Cursor).
{error,invalid_cursor}
12&gt; ok = kterl:cur_jump(Cursor, [{key,"key1"}]).
ok
13&gt; {ok, Res3} = kterl:cur_get(Cursor).
...
14&gt; kterl_result:get_key(Res3).
&lt;&lt;"key1"&gt;&gt;
15&gt; kterl_result:get_value(Res3).
&lt;&lt;"val1"&gt;&gt;
16&gt; {ok,_} = kterl:cur_seize(Cursor).
...</pre>
<p> </p>On success cur_seize/1 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_key(Result).             % The record's key.
kterl_result:get_value(Result).           % The record's value.
kterl_result:get_exptime(Result).         % The record's expiration time (if set.)</pre></p>
<p><b>See also:</b> <a href="#cur_seize-2">cur_seize/2</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_seize-2">cur_seize/2</a></h3>
<div class="spec">
<p><tt>cur_seize(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, OptArgs::[{wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, invalid_cursor} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_seize<p> </p>

<p>Returns the key, value, and if set, the expiration time of the record
located at the cursor. The record is then removed. If the last (or
first, depending on cur_jump/cur_jump_back step order) record is
removed or seized, the cursor is invalidated for future operations
until it's repositioned with a jump call.</p>

<p> </p>On success cur_seize/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_key(Result).             % The record's key.
kterl_result:get_value(Result).           % The record's value.
kterl_result:get_exptime(Result).         % The record's expiration time (if set.)</pre></p>
<p><b>See also:</b> <a href="#cur_seize-1">cur_seize/1</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_set_value-2">cur_set_value/2</a></h3>
<div class="spec">
<p><tt>cur_set_value(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, Value::<a href="#type-kt_value">kt_value()</a>) -&gt; ok | {error, invalid_cursor} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_set_value<p> </p>

<p>Sets the value of the record located at the cursor. This function does
not instruct the server to 'step' the cursor to the next/previous
record after writing a new value. For this, use <a href="#cur_set_value-3"><code>cur_set_value/3</code></a> or <a href="#cur_set_value_opt-2"><code>cur_set_value_opt/2</code></a>.</p>

<pre>% example:

1&gt; kterl:set_bulk(Pid,[{"key1","val1"},{"key2","val2"},{"key3","val3"}]).
...
2&gt; Cursor = kterl:cursor(Pid).
...
3&gt; ok = kterl:cur_jump(Cursor, [{key, "key2"}]).
ok
4&gt; kterl_result:get_value(kterl:cur_get_value(Cursor)).
&lt;&lt;"val2"&gt;&gt;
5&gt; ok = kterl:cur_set_value(Cursor, &lt;&lt;"new val2"&gt;&gt;).
ok
6&gt; kterl_result:get_value(kterl:cur_get_value(Cursor)).
&lt;&lt;"new val2"&gt;&gt;</pre>
<p> </p>On success cur_set_value/2 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#cur_set_value-2">cur_set_value/2</a>, <a href="#cur_set_value_opt-2">cur_set_value_opt/2</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_set_value-3">cur_set_value/3</a></h3>
<div class="spec">
<p><tt>cur_set_value(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, Value::<a href="#type-kt_value">kt_value()</a>, Step::boolean()) -&gt; ok | {error, invalid_cursor} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_set_value<p> </p>

<p>Sets the value of the record located at the cursor. When 'step' is
true, the cursor is positioned to the next or previous record,
depending on if the cursor was positioned with a cur_jump* or
cur_jump_back* call.</p>

<pre>% example:

1&gt; kterl:set_bulk(Pid,[{"key1","val1"},{"key2","val2"},{"key3","val3"}]).
...
2&gt; Cursor = kterl:cursor(Pid).
...
3&gt; ok = kterl:cur_jump(Cursor, [{key, "key2"}]).
ok
4&gt; kterl_result:get_value(kterl:cur_get_value(Cursor)).
&lt;&lt;"val2"&gt;&gt;
5&gt; ok = kterl:cur_set_value(Cursor, &lt;&lt;"new val2"&gt;&gt;, true).
ok
6&gt; kterl_result:get_value(kterl:cur_get_value(Cursor)).
&lt;&lt;"val3"&gt;&gt;
7&gt; ok = kterl:cur_step_back(Cursor).
ok
8&gt; kterl_result:get_value(kterl:cur_get_value(Cursor)).
&lt;&lt;"new val2"&gt;&gt;</pre>

<p> </p>On success cur_set_value/3 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#cur_set_value-1">cur_set_value/1</a>, <a href="#cur_set_value-2">cur_set_value/2</a>, <a href="#cur_set_value_opt-2">cur_set_value_opt/2</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_set_value_opt-2">cur_set_value_opt/2</a></h3>
<div class="spec">
<p><tt>cur_set_value_opt(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, OptArgs::[{value, <a href="#type-kt_value">kt_value()</a>} | {step, boolean()} | {xt, <a href="#type-kt_exptime">kt_exptime()</a>} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, invalid_cursor} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_set_value<p> </p>

<p>Sets the value of the record located at the cursor. Set 'step' to true
for the cursor to step to an adjacent record after the value is
set. This function can also interact with the server's signaling
mechanism with the optional 'wait', 'waittime', 'signal', and
'signalbroad' parameters.</p>

<pre>% example:

1&gt; kterl:set_bulk(Pid,[{"key1","val1"},{"key2","val2"},{"key3","val3"}]).
...
2&gt; Cursor = kterl:cursor(Pid).
...
3&gt; ok = kterl:cur_jump(Cursor, [{key, "key2"}]).
ok
4&gt; kterl_result:get_value(kterl:cur_get_value(Cursor)).
&lt;&lt;"val2"&gt;&gt;
5&gt; {ok,Res} = kterl:cur_set_value_opt(Cursor, [{step, true}, {value, "new val2"}, {signal, "cursor_set"}]).
{ok, ...}
6&gt; kterl_result:get_signaled_count(Res).
0
7&gt; kterl_result:get_value(kterl:cur_get_value(Cursor)).
&lt;&lt;"val3"&gt;&gt;
8&gt; ok = kterl:cur_step_back(Cursor).
ok
9&gt; kterl_result:get_value(kterl:cur_get_value(Cursor)).
&lt;&lt;"new val2"&gt;&gt;</pre>

<p> </p>On success cur_set_value_opt/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#cur_set_value-1">cur_set_value/1</a>, <a href="#cur_set_value-2">cur_set_value/2</a>, <a href="#cur_set_value-3">cur_set_value/3</a>, <a href="#cur_set_value_opt-2">cur_set_value_opt/2</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_step-1">cur_step/1</a></h3>
<div class="spec">
<p><tt>cur_step(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>) -&gt; ok | {error, invalid_cursor} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_step<p> </p>

<p>Positions the cursor to the next record.</p>

<pre>% example:

1&gt; kterl:set_bulk(Pid,[{"key1","val1"},{"key2","val2"},{"key3","val3"}]).
...
2&gt; Cursor = kterl:cursor(Pid).
...
3&gt; ok = kterl:cur_jump(Cursor,[{key, "key2"}]).
ok
4&gt; kterl_result:get_key(kterl:cur_get_key(Cursor)).
&lt;&lt;"key2"&gt;&gt;
5&gt; ok = kterl:cur_step(Cursor).
ok
6&gt; kterl_result:get_key(kterl:cur_get_key(Cursor)).
&lt;&lt;"key3"&gt;&gt;
7&gt; kterl:cur_step(Cursor).
{error,invalid_cursor}</pre>

<p> </p>On success cur_step/1 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#cur_step-2">cur_step/2</a>, <a href="#cur_step_back-1">cur_step_back/1</a>, <a href="#cur_step_back-2">cur_step_back/2</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_step-2">cur_step/2</a></h3>
<div class="spec">
<p><tt>cur_step(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, OptArgs::[{wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, invalid_cursor} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_step<p> </p>

<p>Positions the cursor to the next record. Unlike <a href="#cur_step-1"><code>cur_step/1</code></a>,
this function accepts optional 'wait', 'waittime', 'signal', and
'signalbroad' parameters to interact with the server's signaling
mechanism.</p>

<pre>% example:

1&gt; kterl:set_bulk(Pid,[{"key1","val1"},{"key2","val2"},{"key3","val3"}]).
...
2&gt; Cursor = kterl:cursor(Pid).
3&gt; ok = kterl:cur_jump(Cursor,[{key, "key2"}]).
ok
4&gt; kterl_result:get_key(kterl:cur_get_key(Cursor)).
&lt;&lt;"key2"&gt;&gt;
5&gt; {ok,_} = kterl:cur_step(Cursor,[{signal, "stepped"}]).
{ok, ...}
6&gt; kterl_result:get_key(kterl:cur_get_key(Cursor)).
&lt;&lt;"key3"&gt;&gt;
7&gt; kterl:cur_step(Cursor, [{signal, "stepped"}]).
{error,invalid_cursor}</pre>

<p> </p>On success cur_step/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#cur_step-2">cur_step/2</a>, <a href="#cur_step_back-1">cur_step_back/1</a>, <a href="#cur_step_back-2">cur_step_back/2</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_step_back-1">cur_step_back/1</a></h3>
<div class="spec">
<p><tt>cur_step_back(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>) -&gt; ok | {error, invalid_cursor} | {error, not_implemented} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_step_back<p> </p>

<p>Positions the cursor to the previous record.</p>

<pre>% example:

1&gt; kterl:set_bulk(Pid,[{"key1","val1"},{"key2","val2"},{"key3","val3"}]).
...
2&gt; Cursor = kterl:cursor(Pid).
3&gt; ok = kterl:cur_jump(Cursor,[{key, "key2"}]).
ok
4&gt; kterl_result:get_key(kterl:cur_get_key(Cursor)).
&lt;&lt;"key2"&gt;&gt;
5&gt; ok = kterl:cur_step_back(Cursor).
ok
6&gt; kterl_result:get_key(kterl:cur_get_key(Cursor)).
&lt;&lt;"key1"&gt;&gt;
7&gt; kterl:cur_step_back(Cursor).
{error,invalid_cursor}</pre>

<p> </p>On success cur_step_back/1 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#cur_step-1">cur_step/1</a>, <a href="#cur_step-2">cur_step/2</a>, <a href="#cur_step_back-2">cur_step_back/2</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cur_step_back-2">cur_step_back/2</a></h3>
<div class="spec">
<p><tt>cur_step_back(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>, OptArgs::[{wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, invalid_cursor} | {error, not_implemented} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/cur_step_back<p> </p>

<p>Positions the cursor to the previous record. Unlike <a href="#cur_step_back-1"><code>cur_step_back/1</code></a>, this function accepts optional 'wait', 'waittime',
'signal', and 'signalbroad' parameters to interact with the server's
signaling mechanism.</p>

<pre>% example:

1&gt; kterl:set_bulk(Pid,[{"key1","val1"},{"key2","val2"},{"key3","val3"}]).
...
2&gt; Cursor = kterl:cursor(Pid).
3&gt; ok = kterl:cur_jump(Cursor,[{key, "key2"}]).
ok
4&gt; kterl_result:get_key(kterl:cur_get_key(Cursor)).
&lt;&lt;"key2"&gt;&gt;
5&gt; {ok,_} = kterl:cur_step_back(Cursor,[{signal, "stepped"}]).
{ok, ...}
6&gt; kterl_result:get_key(kterl:cur_get_key(Cursor)).
&lt;&lt;"key1"&gt;&gt;
7&gt; kterl:cur_step_back(Cursor, [{signal, "stepped"}]).
{error,invalid_cursor}</pre>

<p> </p>On success cur_step_back/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#cur_step-1">cur_step/1</a>, <a href="#cur_step-2">cur_step/2</a>, <a href="#cur_step_back-1">cur_step_back/1</a>, <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="cursor-1">cursor/1</a></h3>
<div class="spec">
<p><tt>cursor(Client::<a href="#type-kt_client">kt_client()</a>) -&gt; <a href="#type-kt_cursor">kt_cursor()</a></tt><br></p>
</div><p>

Returns a cursor handle for all subsequent cur_* calls. The cursor
handle retains the process id of the connection handler passed to this
function.
</p>
<p><b>See also:</b> <a href="#cur_get-2">cur_get/2</a>, <a href="#cur_get_key-1">cur_get_key/1</a>, <a href="#cur_get_key-2">cur_get_key/2</a>, <a href="#cur_get_value-1">cur_get_value/1</a>, <a href="#cur_get_value-2">cur_get_value/2</a>, <a href="#cur_jump-1">cur_jump/1</a>, <a href="#cur_jump-2">cur_jump/2</a>, <a href="#cur_jump_back-1">cur_jump_back/1</a>, <a href="#cur_jump_back-2">cur_jump_back/2</a>, <a href="#cur_remove-1">cur_remove/1</a>, <a href="#cur_seize-1">cur_seize/1</a>, <a href="#cur_set_value-2">cur_set_value/2</a>, <a href="#cur_set_value-3">cur_set_value/3</a>, <a href="#cur_step_back-1">cur_step_back/1</a>, <a href="#release_cursor-1">release_cursor/1</a>.</p>

<h3 class="function"><a name="echo-2">echo/2</a></h3>
<div class="spec">
<p><tt>echo(Client::<a href="#type-kt_client">kt_client()</a>, KVL::<a href="#type-kt_call_kvl">kt_call_kvl()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/echo<p> </p>
The server will echo the key,value pairs passed to this call. 
<pre>% example:

1&gt; {ok, Res} = kterl:echo(Pid, [{"hello","world"}]),
2&gt; [{&lt;&lt;"hello"&gt;&gt;, &lt;&lt;"world"&gt;&gt;}] = kterl_result:get_records(Res).</pre>

<p> </p>On success echo/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_records(Result).         % All records.
kterl_result:get_num(Result).             % The result from an increment call, or a record count.</pre>
</p>

<h3 class="function"><a name="garbage_collect-1">garbage_collect/1</a></h3>
<div class="spec">
<p><tt>garbage_collect(Client::<a href="#type-kt_client">kt_client()</a>) -&gt; ok</tt><br></p>
</div><p>Forces the connection handler to perform garbage collection.</p>

<h3 class="function"><a name="get-2">get/2</a></h3>
<div class="spec">
<p><tt>get(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, no_record} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/get<p> </p>

<p>Retrieve a key's value from the primary database. The record's
expiration time, if set, is available in the results.</p>

<pre>% example: setting a record with an expiration time 60 seconds in the future:

1&gt; {ok, _} = kterl:set(Pid, "test_exp", &lt;&lt;"60..59..58.."&gt;&gt;, [{xt,60}]).
...
2&gt; {ok, Res} = kterl:get(Pid, &lt;&lt;"test_exp"&gt;&gt;),
3&gt; kterl_result:get_value(Res).
&lt;&lt;"60..59..58.."&gt;&gt;
4&gt; kterl_result:get_exptime(Res).
1332365348
5&gt; kterl_result:get_exptime_datetime(Res).
{{2012,3,21},{14,29,8}}
6&gt; kterl_result:get_exptime_future_seconds(Res).
29</pre>
Wait until the record expires...
<pre>7&gt; kterl:get(Pid, &lt;&lt;"test_exp"&gt;&gt;).
{error, no_record}</pre>

<p>If the record does not have an expiration time set, the get_exptime
functions in kterl_result will return undefined:</p>

<pre>1&gt; {ok, _} = kterl:set(Pid, &lt;&lt;"test_key"&gt;&gt;, &lt;&lt;"test_value"&gt;&gt;).
...
2&gt; kterl_result:get_exptime(kterl:get(Pid, "test_key")).
undefined</pre>

<p> </p>On success get/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_value(Result).           % The record's value.
kterl_result:get_exptime(Result).         % The record's expiration time (if set.)</pre></p>
<p><b>See also:</b> <a href="#get-3">get/3</a>.</p>

<h3 class="function"><a name="get-3">get/3</a></h3>
<div class="spec">
<p><tt>get(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {wait, binary() | string()} | {waittime, non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, no_record} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/get<p> </p>

<p>Retrieve a key's value, optionally specifying a database and signal
parameters. The record's expiration time, if set, is available in the
results.</p>

<h4><a name="example_1">example 1</a></h4>
<pre>% retrieve the user record from the users database.
get_user(Pid, Username) -&gt;
    case kterl:get(Pid, Username, [{database, "users.kct"}]) of
        {ok, Res} -&gt;
            {ok, kterl_result:get_value(Res)};
        {error, timed_out} -&gt;
            throw({error, {no_user_record, Username}})
    end.</pre>

<h4><a name="example_2">example 2</a></h4>

<pre>% another process will create an auto-expiring status record in the
% stats database and then will send a "stats_set" signal. get_stats_record 
% will wait for the signal for up to 60 seconds, and when it's received,
% it will retrieve the status value and the record's expiration time.

get_stats_record(Pid) -&gt;
    case kterl:get(Pid, "status", 
                   [{database, "stats.kct"},
                    {wait,     "stats_set"},
                    {waittime, 60}]) of
        {ok, Res} -&gt;
            Value = kterl_result:get_value(Res),
            Exptime = kterl_result:get_exptime_datetime(Res),
            {ok, Value, Exptime};
        {error, Err} when Err =:= no_record; Err =:= timed_out -&gt;
            throw({error, {get_stats, Err}})
end.</pre>
<p> </p>On success get/3 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_value(Result).           % The record's value.
kterl_result:get_exptime(Result).         % The record's expiration time (if set.)
kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#get-2">get/2</a>.</p>

<h3 class="function"><a name="get_bulk-2">get_bulk/2</a></h3>
<div class="spec">
<p><tt>get_bulk(Client::<a href="#type-kt_client">kt_client()</a>, Keys::<a href="#type-kt_key_list">kt_key_list()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>

Calls /rpc/get_bulk<p> </p>

<p>Retrieves multiple records at once. <a href="#bin_get_bulk-2"><code>bin_get_bulk/2</code></a> is significantly faster than this call.</p>

<pre>% example:

1&gt; Records = [{"key1","val1"}, {&lt;&lt;"key2"&gt;&gt;, &lt;&lt;"val2"&gt;&gt;}, {"key3", 1234}, {"key4",1.23}].
...
2&gt; {ok, _} = kterl:set_bulk(Pid, Records).
...
3&gt; kterl_result:get_records(kterl:get_bulk(Pid, ["missing_key" | [Key || {Key,_} &lt;- Records]])).
[{&lt;&lt;"key1"&gt;&gt;,&lt;&lt;"val1"&gt;&gt;},
 {&lt;&lt;"key2"&gt;&gt;,&lt;&lt;"val2"&gt;&gt;},
 {&lt;&lt;"key3"&gt;&gt;,&lt;&lt;"1234"&gt;&gt;},
 {&lt;&lt;"key4"&gt;&gt;,&lt;&lt;"1.230000"&gt;&gt;}]</pre>
<p> </p>On success get_bulk/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_records(Result).         % All records.</pre></p>
<p><b>See also:</b> <a href="#bin_get_bulk-2">bin_get_bulk/2</a>, <a href="#get_bulk-3">get_bulk/3</a>.</p>

<h3 class="function"><a name="get_bulk-3">get_bulk/3</a></h3>
<div class="spec">
<p><tt>get_bulk(Client::<a href="#type-kt_client">kt_client()</a>, Keys::<a href="#type-kt_key_list">kt_key_list()</a>, OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {atomic, boolean()} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>

Calls /rpc/get_bulk<p> </p>

<p>Retrieves multiple records at once. Optionally, the database and/or
signal operations, and an option to force atomicity can be
specified. <a href="#bin_get_bulk-2"><code>bin_get_bulk/2</code></a> is significantly faster than this call, but
it lacks the ability to configure signal operations, atomicity, or
specify the destination database as a string.</p>

<pre>% example: waits up to 60 seconds for a "stats_avail" signal, and then attempts to
% retrieve 10000 records in a bulk operation. it returns the records that were available.

get_bulk_demo(Pid) -&gt;
    Keys = ["status_" ++ integer_to_list(N) || N &lt;- lists:seq(1,10000)],
    case kterl:get_bulk(Pid, Keys, [{database, "status.kct"},
                                    {wait,     "stats_avail"},
                                    {waittime, 60}]) of
        {ok, Res} -&gt;
            {ok, kterl_result:get_records(Res)};
        Error = {error, _} -&gt;
            Error
    end.</pre>
<p> </p>On success get_bulk/3 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_records(Result).         % All records.
kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#bin_get_bulk-2">bin_get_bulk/2</a>, <a href="#get_bulk-2">get_bulk/2</a>.</p>

<h3 class="function"><a name="increment-3">increment/3</a></h3>
<div class="spec">
<p><tt>increment(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, Num::string() | binary() | integer()) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, incompatible_record} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/increment<p> </p>

<p>Adds a number to the numeric integer value of a record, and returns
the resulting value. It must be used to set an initial value for
subsequent increment calls.</p>

<pre>% example:

1&gt; kterl:get(Pid, "inc_test").
{error,no_record}.
2&gt; {ok, Res} = kterl:increment(Pid, "inc_test", 1).
...
3&gt; kterl_result:get_num(Res).
1
4&gt; kterl_result:get_num(kterl:increment(Pid, "inc_test", -2)).
-1
5&gt; kterl_result:get_num(kterl:increment(Pid, "inc_test", 101)).
100</pre>

<p>The system can simply increment 0 to retrieve the current value, but
be aware that it'll create the record if it doesn't exist.</p>

<pre>6&gt; kterl_result:get_num(kterl:increment(Pid, "inc_test", 0)).
100
7&gt; kterl_result:get_value(kterl:get(Pid, "inc_test")).
&lt;&lt;0,0,0,0,0,0,0,100&gt;&gt;</pre>

<p>Notice: The server is unable to increment a value that was set by a non-increment call:</p>

<pre>8&gt; ok = kterl:add(Pid, "inc_fail", 1).
ok
9&gt; kterl_result:get_value(kterl:get(Pid, "inc_fail")).
&lt;&lt;"1"&gt;&gt;
10&gt; kterl:increment(Pid, "inc_fail", 1).
{error,incompatible_record}</pre>

<p> </p>On success increment/3 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_num(Result).             % The result from an increment call, or a record count.</pre></p>
<p><b>See also:</b> <a href="#increment-4">increment/4</a>, <a href="#increment_double-3">increment_double/3</a>, <a href="#increment_double-4">increment_double/4</a>.</p>

<h3 class="function"><a name="increment-4">increment/4</a></h3>
<div class="spec">
<p><tt>increment(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, Num::string() | binary() | integer(), OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {xt, <a href="#type-kt_exptime">kt_exptime()</a>} | {orig, integer()} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, incompatible_record} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/increment<p> </p>

<p>Adds a number to the numeric integer value of a record, and returns
the resulting value. It must be used to set an initial value for
subsequent increment calls.</p>

<pre>% example: this function updates a resource counter in the "resource.kct" database.
% the record will automatically expire in one minute after the final increment call is
% performed on this key.

inc_resource_count(Pid, ResourceName) -&gt;
    ok = kterl:increment(Pid, ResourceName, 1, 
                         [{database, "resource.kct"},
                          {xt, 60}]).</pre>
<p> </p>On success increment/4 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_num(Result).             % The result from an increment call, or a record count.
kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#increment-3">increment/3</a>, <a href="#increment_double-3">increment_double/3</a>, <a href="#increment_double-4">increment_double/4</a>.</p>

<h3 class="function"><a name="increment_double-3">increment_double/3</a></h3>
<div class="spec">
<p><tt>increment_double(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, Num::string() | binary() | number()) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, incompatible_record} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/increment_double<p> </p>

<p>Adds a number to the numeric double value of a record, and returns the
resulting value. It must be used to set an initial value for
subsequent increment_double calls.</p>

<pre>% example:

1&gt; kterl:get(Pid, "incd_test").
{error,no_record}
2&gt; {ok, Res} = kterl:increment_double(Pid, "incd_test", 5.2).
...
3&gt; kterl_result:get_num(Res).
5.2
4&gt; kterl_result:get_num(kterl:increment_double(Pid, "incd_test", -6.2)).
-1.0
5&gt; kterl_result:get_num(kterl:increment_double(Pid, "incd_test", 1.01)).
0.01</pre>

<p>The system can simply increment 0 to retrieve the current value, but
notice that it'll create the record if it doesn't exist.</p>

<pre>6&gt; kterl_result:get_num(kterl:increment_double(Pid, "incd_test", 0)).
0.01
7&gt; kterl_result:get_value(kterl:get(Pid, "incd_test")).
&lt;&lt;0,0,0,0,0,0,0,0,0,0,9,24,78,114,160,0&gt;&gt;</pre>

<p>Notice: The server is unable to increment a value that was set by a non-increment call:</p>

<pre>8&gt; ok = kterl:add(Pid, "incd_fail", 1.0).
ok
9&gt; kterl_result:get_value(kterl:get(Pid, "incd_fail")).
&lt;&lt;"1.000000"&gt;&gt;
10&gt; kterl:increment(Pid, "incd_fail", 1.0).
{error,incompatible_record}</pre>

<p> </p>On success increment_double/3 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_num(Result).             % The result from an increment call, or a record count.</pre></p>
<p><b>See also:</b> <a href="#increment-3">increment/3</a>, <a href="#increment-4">increment/4</a>, <a href="#increment_double-4">increment_double/4</a>.</p>

<h3 class="function"><a name="increment_double-4">increment_double/4</a></h3>
<div class="spec">
<p><tt>increment_double(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, Num::string() | binary() | number(), OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {xt, <a href="#type-kt_exptime">kt_exptime()</a>} | {orig, number()} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, incompatible_record} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/increment_double<p> </p>

<p>Adds a number to the numeric double value of a record, and returns the
resulting value. It must be used to set an initial value for
subsequent increment_double calls.</p>

<pre>% example: this function updates a counter in the "sysstat.kct" database.

inc_sys_counter(Pid, Key, Success) -&gt;
    Value = case Success of 
                true -&gt; 2.3;
                false -&gt; -1.1
            end,
    ok = kterl:increment_double(Pid, Key, Value, [{database, "sysstat.kct"}]).</pre>

<p> </p>On success increment_double/4 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_num(Result).             % The result from an increment call, or a record count.
kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#increment-3">increment/3</a>, <a href="#increment-4">increment/4</a>, <a href="#increment_double-3">increment_double/3</a>.</p>

<h3 class="function"><a name="local_stats-1">local_stats/1</a></h3>
<div class="spec">
<p><tt>local_stats(Client::<a href="#type-kt_client">kt_client()</a>) -&gt; [{atom(), any()}]</tt><br></p>
</div><p>Returns stats maintained by the local connection handler.</p>

<h3 class="function"><a name="match_prefix-2">match_prefix/2</a></h3>
<div class="spec">
<p><tt>match_prefix(Client::<a href="#type-kt_client">kt_client()</a>, Prefix::<a href="#type-kt_str">kt_str()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/match_prefix<p> </p>

<p>Retrieves all keys from the primary database that match a prefix
string. An empty prefix string returns all keys in a database. If the
number of key results need to be restricted, use <a href="#match_prefix-3"><code>match_prefix/3</code></a> with
the 'max' parameter.</p>

<pre>% example:

1&gt; Records = [{K ++ integer_to_list(V), V} || K &lt;- ["key_a", "key_b", "key_c"] || V &lt;- [1,2,3,4]].
...
2&gt; {ok, SetRes} = kterl:set_bulk(Pid, Recs).
...
3&gt; kterl_result:get_num(SetRes).
12
4&gt; {ok, Res} = kterl:match_prefix(Pid, &lt;&lt;"key_c"&gt;&gt;).
...
5&gt; kterl_result:get_keys(Res).
[&lt;&lt;"key_c1"&gt;&gt;,&lt;&lt;"key_c2"&gt;&gt;,&lt;&lt;"key_c3"&gt;&gt;,&lt;&lt;"key_c4"&gt;&gt;]
6&gt; kterl_result:get_keys(kterl:match_prefix(Pid, &lt;&lt;"key_d"&gt;&gt;)).
[]
7&gt; kterl_result:get_keys(kterl:match_prefix(Pid, "")).
[&lt;&lt;"key_a1"&gt;&gt;,&lt;&lt;"key_a2"&gt;&gt;,&lt;&lt;"key_a3"&gt;&gt;,&lt;&lt;"key_a4"&gt;&gt;,
 &lt;&lt;"key_b1"&gt;&gt;,&lt;&lt;"key_b2"&gt;&gt;,&lt;&lt;"key_b3"&gt;&gt;,&lt;&lt;"key_b4"&gt;&gt;,
 &lt;&lt;"key_c1"&gt;&gt;,&lt;&lt;"key_c2"&gt;&gt;,&lt;&lt;"key_c3"&gt;&gt;,&lt;&lt;"key_c4"&gt;&gt;]</pre>
<p> </p>On success match_prefix/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_keys(Result).            % All matching keys.</pre></p>
<p><b>See also:</b> <a href="#match_prefix-3">match_prefix/3</a>, <a href="#match_regex-2">match_regex/2</a>, <a href="#match_regex-3">match_regex/3</a>.</p>

<h3 class="function"><a name="match_prefix-3">match_prefix/3</a></h3>
<div class="spec">
<p><tt>match_prefix(Client::<a href="#type-kt_client">kt_client()</a>, Prefix::<a href="#type-kt_str">kt_str()</a>, OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {max, non_neg_integer()} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/match_prefix<p> </p>

<p>Retrieves all keys from a optionally specified database that match a
prefix string. An empty string matches all keys in that
database. There is a 'max' parameter, which provides the ability to
limit the number of keys returned by the server. Additionally, this
call supports the signal wait/broadcast functionality.</p>

<pre>% example: Wait up to 10 minutes for a 'scan_cache' signal on the
% "cache.kct" database, and retrieve up to 1000 keys that have 
% the prefix "cache_".

scan_cache(Pid) -&gt;
    case kterl:match_prefix(Pid, "cache_", [{database, "cache.kct"},
                                            {max,      1000},
                                            {wait,     "scan_cache"},
                                            {waittime, 10 * 60}]) of
        {ok, Res} -&gt;
            {ok, kterl_result:get_keys(Res)};
        Error = {error, _} -&gt;
            Error
    end.</pre>
<p> </p>On success match_prefix/3 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_keys(Result).            % All matching keys.
kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#match_prefix-2">match_prefix/2</a>.</p>

<h3 class="function"><a name="match_regex-2">match_regex/2</a></h3>
<div class="spec">
<p><tt>match_regex(Client::<a href="#type-kt_client">kt_client()</a>, Regex::<a href="#type-kt_str">kt_str()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/match_regex<p> </p>

<p>Retrieves all keys from the primary database that match a regular
expression. An empty regex parameter returns all keys in a
database. If the number of key results need to be restricted, use
<a href="#match_regex-3"><code>match_regex/3</code></a> with the 'max' parameter.</p>

<pre>% example:

1&gt; Records = [{K ++ integer_to_list(V), V} || K &lt;- ["key_a", "key_b", "key_c"] || V &lt;- [1,2,3,4]].
...
2&gt; {ok, SetRes} = kterl:set_bulk(Pid, Recs).
...
3&gt; kterl_result:get_num(SetRes).
12
4&gt; kterl_result:get_keys(kterl:match_regex(Pid, "key_.4")).
[&lt;&lt;"key_a4"&gt;&gt;,&lt;&lt;"key_b4"&gt;&gt;,&lt;&lt;"key_c4"&gt;&gt;]
5&gt; kterl_results:get_keys(kterl:match_regex(Pid, "key_[a|c]4")).
[&lt;&lt;"key_a4"&gt;&gt;,&lt;&lt;"key_c4"&gt;&gt;]
6&gt; kterl_result:get_keys(kterl:match_regex(Pid, "")).
[&lt;&lt;"key_a1"&gt;&gt;,&lt;&lt;"key_a2"&gt;&gt;,&lt;&lt;"key_a3"&gt;&gt;,&lt;&lt;"key_a4"&gt;&gt;,
 &lt;&lt;"key_b1"&gt;&gt;,&lt;&lt;"key_b2"&gt;&gt;,&lt;&lt;"key_b3"&gt;&gt;,&lt;&lt;"key_b4"&gt;&gt;,
 &lt;&lt;"key_c1"&gt;&gt;,&lt;&lt;"key_c2"&gt;&gt;,&lt;&lt;"key_c3"&gt;&gt;,&lt;&lt;"key_c4"&gt;&gt;]</pre>
<p> </p>On success match_regex/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_keys(Result).            % All matching keys.</pre></p>
<p><b>See also:</b> <a href="#match_regex-3">match_regex/3</a>.</p>

<h3 class="function"><a name="match_regex-3">match_regex/3</a></h3>
<div class="spec">
<p><tt>match_regex(Client::<a href="#type-kt_client">kt_client()</a>, Regex::<a href="#type-kt_str">kt_str()</a>, OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {max, non_neg_integer()} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/match_regex<p> </p>

<p>Retrieves all keys from a database that match a regular expression. An
empty regex parameter returns all keys in a database. The optional
parameter 'max' can be used to limit the number of results. This call
also supports the signal/wait signaling mechanism.</p>

<pre>% example: the database file 'dictionary.kct' was populated with
% an english wordlist. Retrieve words that match a regular expression.

match_dict(Pid, Regex) -&gt;
    {ok, Res} = kterl:match_regex(Pid, Regex, [{database, "dictionary.kct"}]),
    kterl_result:get_keys(Res).

1&gt; match_dict(Pid, "(^c..$|^(a|z).$)").
[&lt;&lt;"ad"&gt;&gt;,&lt;&lt;"ah"&gt;&gt;,&lt;&lt;"am"&gt;&gt;,&lt;&lt;"an"&gt;&gt;,&lt;&lt;"as"&gt;&gt;,&lt;&lt;"at"&gt;&gt;,
 &lt;&lt;"ax"&gt;&gt;,&lt;&lt;"ay"&gt;&gt;,&lt;&lt;"cab"&gt;&gt;,&lt;&lt;"cad"&gt;&gt;,&lt;&lt;"cam"&gt;&gt;,&lt;&lt;"can"&gt;&gt;,
 &lt;&lt;"cap"&gt;&gt;,&lt;&lt;"car"&gt;&gt;,&lt;&lt;"cat"&gt;&gt;,&lt;&lt;"caw"&gt;&gt;,&lt;&lt;"chi"&gt;&gt;,&lt;&lt;"cob"&gt;&gt;,
 &lt;&lt;"cod"&gt;&gt;,&lt;&lt;"cog"&gt;&gt;,&lt;&lt;"con"&gt;&gt;,&lt;&lt;"coo"&gt;&gt;,&lt;&lt;"cop"&gt;&gt;,&lt;&lt;"cot"&gt;&gt;,
 &lt;&lt;"cow"&gt;&gt;,&lt;&lt;"cox"&gt;&gt;,&lt;&lt;"coy"&gt;&gt;,&lt;&lt;"cry"&gt;&gt;,&lt;&lt;...&gt;&gt;|...]
2&gt; length(match_dict(Pid, "")).
99183</pre>
<p> </p>On success match_regex/3 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_keys(Result).            % All matching keys.
kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#match_regex-2">match_regex/2</a>.</p>

<h3 class="function"><a name="play_script-2">play_script/2</a></h3>
<div class="spec">
<p><tt>play_script(Client::<a href="#type-kt_client">kt_client()</a>, Name::<a href="#type-kt_str">kt_str()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/play_script<p> </p>
Invokes a procedure of the server's script language extension.
<pre>% example:

play_kt_script(Pid, Script) -&gt;
    {ok, Res} = kterl:play_script(Pid, Script),
    kterl_result:get_records(Res).

1&gt; play_kt_script(Pid, &lt;&lt;"script_name"&gt;&gt;).
[{&lt;&lt;"result_1_key"&gt;&gt;,&lt;&lt;"result_1_value"&gt;&gt;}},
 {&lt;&lt;"result_2_key"&gt;&gt;,&lt;&lt;"result_2_value"&gt;&gt;}]</pre>
<p> </p>On success play_script/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_records(Result).         % All records.
kterl_result:get_num(Result).             % The result from an increment call, or a record count.</pre></p>
<p><b>See also:</b> <a href="#bin_play_script-3">bin_play_script/3</a>, <a href="#play_script-3">play_script/3</a>, <a href="#play_script-4">play_script/4</a>.</p>

<h3 class="function"><a name="play_script-3">play_script/3</a></h3>
<div class="spec">
<p><tt>play_script(Client::<a href="#type-kt_client">kt_client()</a>, Name::<a href="#type-kt_str">kt_str()</a>, ScriptArgs::<a href="#type-kt_call_kvl">kt_call_kvl()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/play_script<br>
Invokes a procedure of the server's script language extension.
<pre>% example:

play_kt_script(Pid, Script, Args) -&gt;
    {ok, Res} = kterl:play_script(Pid, Script, Args),
    kterl_result:get_records(Res).
 
1&gt; play_kt_script(Pid, "scriptname", [{"arg1","val1"},{"arg2"},{"val2"}]).
[{&lt;&lt;"result_1_key"&gt;&gt;,&lt;&lt;"result_1_value"&gt;&gt;}},
 {&lt;&lt;"result_2_key"&gt;&gt;,&lt;&lt;"result_2_value"&gt;&gt;}]</pre>
<p> </p>On success play_script/3 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_records(Result).         % All records.
kterl_result:get_num(Result).             % The result from an increment call, or a record count.</pre></p>
<p><b>See also:</b> <a href="#bin_play_script-3">bin_play_script/3</a>, <a href="#play_script-2">play_script/2</a>, <a href="#play_script-4">play_script/4</a>.</p>

<h3 class="function"><a name="play_script-4">play_script/4</a></h3>
<div class="spec">
<p><tt>play_script(Client::<a href="#type-kt_client">kt_client()</a>, Name::<a href="#type-kt_str">kt_str()</a>, ScriptArgs::<a href="#type-kt_call_kvl">kt_call_kvl()</a>, OptArgs::[{wait, binary() | string} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | <a href="#type-kt_http_error">kt_http_error()</a> | {error, timed_out}</tt><br></p>
</div><p>Calls /rpc/play_script<p> </p>
Invokes a procedure of the server's script language extension.
<pre>% example:
% this plays a script without args, and then uses the server's
% signaling mechanism to notify all other clients waiting for that signal.
% it returns the script's output and the number of clients that received
% the signal.

-spec play_kt_script(Pid::pid(), Script::binary()) -&gt;
      {ok, [{Key::binary(), Value::binary()}], non_neg_integer()}.

play_kt_script(Pid, Script) -&gt;
    {ok, Res} = kterl:play_script(Pid, Script, [], 
                   [{signal, "script"}, {signalbroad, true}]).
    Records  = kterl:get_records(Res),
    Signaled = kterl:get_signaled_count(Res),
    {ok, Records, Signaled}.</pre>
<p> </p>On success play_script/4 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_records(Result).         % All records.
kterl_result:get_num(Result).             % The result from an increment call, or a record count.
kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#bin_play_script-3">bin_play_script/3</a>, <a href="#play_script-2">play_script/2</a>, <a href="#play_script-3">play_script/3</a>.</p>

<h3 class="function"><a name="release_cursor-1">release_cursor/1</a></h3>
<div class="spec">
<p><tt>release_cursor(Cursor::<a href="#type-kt_cursor">kt_cursor()</a>) -&gt; ok | {error, invalid_cursor} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Release the cursor by invoking /rpc/cur_delete.<p> </p> 

The documentation states this will delete the cursor implicitly. As of
kyoto tycoon 0.9.53, calling /rpc/cur_delete will invalidate the
cursor until a jump call is performed.
</p>
<p><b>See also:</b> <a href="#cursor-1">cursor/1</a>.</p>

<h3 class="function"><a name="remove-2">remove/2</a></h3>
<div class="spec">
<p><tt>remove(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>) -&gt; ok | {error, no_record} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/remove<p> </p>

Removes a record from the primary database.
<pre>% example:

1&gt; ok = kterl:set(Pid, "test", "record").
ok
2&gt; kterl_result:get_value(kterl:get(Pid, &lt;&lt;"test"&gt;&gt;)).
&lt;&lt;"record"&gt;&gt;
3&gt; ok = kterl:remove("test").
ok
4&gt; kterl:get(Pid,"test").
{error,no_record}</pre>
See the cas() function to perform an atomic value compare-and-remove operation.
<p> </p>On success remove/2 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#cas-3">cas/3</a>, <a href="#remove-3">remove/3</a>.</p>

<h3 class="function"><a name="remove-3">remove/3</a></h3>
<div class="spec">
<p><tt>remove(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {wait, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, no_record} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/remove<p> </p>

<p>Removes a record, with the option to specify a database and/or perform signal operations.</p>

<pre>% contrived example: add a record to the stats database with a 10 second
% expiration time. on success, send a signal that it was added. wait an
% hour for another process to collect that record, and then remove it.

write_status(Pid, Stats) -&gt;
    {ok, Res} = kterl:set(Pid, "stats_1234", Stats, 
                          [{database, "stats.kct"},
                           {xt,       10}, 
                           {signal,   "stats_ready"}]),

    %% ensure the signal was collected
    true = kterl_result:get_signaled_count(Res) &gt; 0,

    case kterl:remove(Pid, "stats_1234",
                      [{database, "stats.kct"},
                       {wait,     "stats_collected"},
                       {waittime, 60 * 60}]) of
        {ok, _} -&gt; 
            ok;
        {error, Res} when Res =:= timed_out; Res =:= no_record -&gt;
            throw({error, {dump_status, Err}})
    end.</pre>
<p> </p>On success remove/3 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#cas-3">cas/3</a>, <a href="#remove-2">remove/2</a>.</p>

<h3 class="function"><a name="remove_bulk-2">remove_bulk/2</a></h3>
<div class="spec">
<p><tt>remove_bulk(Client::<a href="#type-kt_client">kt_client()</a>, Keys::<a href="#type-kt_key_list">kt_key_list()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>

Calls /rpc/remove_bulk<p> </p>

<p>Removes multiple records at once, returning the number of record
deletions. <a href="#bin_remove_bulk-2"><code>bin_remove_bulk/2</code></a> is significantly faster than this call.</p>

<pre>% example:

1&gt; Records = [{"key1","val1"}, {&lt;&lt;"key2"&gt;&gt;, &lt;&lt;"val2"&gt;&gt;}, {"key3", 1234}, {"key4",1.23}].
...
2&gt; {ok, _} = kterl:set_bulk(Pid, Records).
...
3&gt; kterl_result:get_records(kterl:get_bulk(Pid, [Key || {Key,_} &lt;- Records])).
[{&lt;&lt;"key1"&gt;&gt;,&lt;&lt;"val1"&gt;&gt;},
 {&lt;&lt;"key2"&gt;&gt;,&lt;&lt;"val2"&gt;&gt;},
 {&lt;&lt;"key3"&gt;&gt;,&lt;&lt;"1234"&gt;&gt;},
 {&lt;&lt;"key4"&gt;&gt;,&lt;&lt;"1.230000"&gt;&gt;}]
4&gt; {ok, Res} = kterl:remove_bulk(Pid, [Key || {Key,_} &lt;- Records]).
...
5&gt; kterl_result:get_num(Res).
4
6&gt; kterl_result:get_records(kterl:get_bulk(Pid, [Key || {Key,_} &lt;- Records])).
[]</pre>
<p> </p>On success remove_bulk/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_num(Result).             % The result from an increment call, or a record count.</pre></p>
<p><b>See also:</b> <a href="#bin_remove_bulk-2">bin_remove_bulk/2</a>, <a href="#remove_bulk-3">remove_bulk/3</a>.</p>

<h3 class="function"><a name="remove_bulk-3">remove_bulk/3</a></h3>
<div class="spec">
<p><tt>remove_bulk(Client::<a href="#type-kt_client">kt_client()</a>, Keys::<a href="#type-kt_key_list">kt_key_list()</a>, OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {atomic, boolean()} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>

Calls /rpc/remove_bulk<p> </p>

<p>Removes multiple records at once, returning the numbers of records
stored. Optionally, the database and/or signal operations, and an
option to force atomicity can be specified. <a href="#bin_remove_bulk-2"><code>bin_remove_bulk/2</code></a> is
significantly faster than this call, but it lacks the ability to
configure signal operations, atomicity, or specify the destination
database as a string.</p>

<pre>% example: This function attempts to remove records from the "status.kct"
% database. It returns the number of records removed.

remove_status_record(Pid) -&gt;
    Keys = ["status_" ++ integer_to_list(N) || N &lt;- lists:seq(1,1000)],
    case kterl:remove_bulk(Pid, Keys, [{database, "status.kct"}]) of
        {ok, Res} -&gt;
            {ok, kterl_result:get_num(Res)};
        Error = {error, _} -&gt;
            Error
end.</pre>

<p> </p>On success remove_bulk/3 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_num(Result).             % The result from an increment call, or a record count.
kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#bin_remove_bulk-2">bin_remove_bulk/2</a>, <a href="#remove_bulk-2">remove_bulk/2</a>.</p>

<h3 class="function"><a name="replace-2">replace/2</a></h3>
<div class="spec">
<p><tt>replace(Client::<a href="#type-kt_client">kt_client()</a>, KeyValue::<a href="#type-kt_kv">kt_kv()</a>) -&gt; ok | {error, no_record} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/replace<p> </p>

<p>Replaces the value of an existing record in the primary database.</p>

<pre>% example:

1&gt; Record1 = {&lt;&lt;"key"&gt;&gt;, &lt;&lt;"value"&gt;&gt;}.
2&gt; Record2 = {&lt;&lt;"key"&gt;&gt;, &lt;&lt;"new value"&gt;&gt;}.

3&gt; ok = kterl:set(Pid, Record1).
ok
4&gt; {ok, Res} = kterl:get(Pid &lt;&lt;"key"&gt;&gt;).
...
5&gt; kterl_result:get_value(Res).
&lt;&lt;"value"&gt;&gt;
6&gt; ok = kterl:replace(Pid, Record2).
ok
7&gt; {ok, Res1} = kterl:get(Pid, &lt;&lt;"key"&gt;&gt;).
...
8&gt; kterl_result:get_value(Res).
&lt;&lt;"new value"&gt;&gt;
9&gt; kterl_replace(Pid, {"new_record","new_value"}).
{error,no_record}</pre>
<p> </p>On success replace/2 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#cas-3">cas/3</a>, <a href="#cas-4">cas/4</a>, <a href="#replace-3">replace/3</a>, <a href="#replace-4">replace/4</a>.</p>

<h3 class="function"><a name="replace-3">replace/3</a></h3>
<div class="spec">
<p><tt>replace(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, Value::<a href="#type-kt_value">kt_value()</a>) -&gt; ok | {error, no_record} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/replace<p> </p>

<p>Replaces the value of an existing record in the primary database.</p>

<pre>% example:

update_user_record(Pid, Username, UserRecord) -&gt;
    case kterl:replace(Pid, Username, UserRecord) of
        ok -&gt; ok;
        {error, no_record} -&gt; throw({error, {no_user, Username}})
    end.</pre>
        
<p> </p>On success replace/3 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#cas-3">cas/3</a>, <a href="#cas-4">cas/4</a>, <a href="#replace-2">replace/2</a>, <a href="#replace-4">replace/4</a>.</p>

<h3 class="function"><a name="replace-4">replace/4</a></h3>
<div class="spec">
<p><tt>replace(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, Value::<a href="#type-kt_value">kt_value()</a>, OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {xt, <a href="#type-kt_exptime">kt_exptime()</a>} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, no_record} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/replace<p> </p>

<p>Replaces the value of an existing record. Use this call to specify the
database, to set an expiration time of the updated record, or to
configure signal/wait parameters.</p>

<pre>% example: this updates a record in the "system.kct" database with
% an expiration time of one hour.

update_system_record(Pid, SystemKey, SystemRecord) -&gt;
    case kterl:replace(Pid, SystemKey, SystemRecord,
                       [{database, "system.kct"}, 
                        {xt, 60 * 60}]) of
        ok -&gt; ok;
        {error, no_record} -&gt; throw({error, {no_sys_record, SystemKey}})
    end.</pre>
        
<p> </p>On success replace/4 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#cas-3">cas/3</a>, <a href="#cas-4">cas/4</a>, <a href="#replace-2">replace/2</a>, <a href="#replace-4">replace/4</a>.</p>

<h3 class="function"><a name="report-1">report/1</a></h3>
<div class="spec">
<p><tt>report(Client::<a href="#type-kt_client">kt_client()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/report<p> </p>
Returns a set of key,value pairs containing server information.
<pre>1&gt; {ok, Res} = kterl:report(Pid).
...
2&gt; kterl_result:get_records(Res).
[{&lt;&lt;"cnt_get"&gt;&gt;,&lt;&lt;"13"&gt;&gt;},
 {&lt;&lt;"cnt_get_misses"&gt;&gt;,&lt;&lt;"4"&gt;&gt;},
 {&lt;&lt;"cnt_misc"&gt;&gt;,&lt;&lt;"0"&gt;&gt;},
 {&lt;&lt;"cnt_remove"&gt;&gt;,&lt;&lt;"0"&gt;&gt;},
 {&lt;&lt;"cnt_remove_misses"&gt;&gt;,&lt;&lt;"0"&gt;&gt;},
 ... ]</pre>

<p> </p>On success report/1 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_records(Result).         % All records.
kterl_result:get_num(Result).             % The result from an increment call, or a record count.</pre>
</p>

<h3 class="function"><a name="seize-2">seize/2</a></h3>
<div class="spec">
<p><tt>seize(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, no_record} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>

Calls /rpc/seize<p> </p>

<p>Retrieve and remove a record from the primary database in one atomic
operation. The call returns the record's value, and if set, the
record's expiration time.</p>

<pre>1&gt; ok = kterl:set(Pid, &lt;&lt;"key"&gt;&gt;, &lt;&lt;"value"&gt;&gt;, [{xt, 10}]).
ok
2&gt; {ok, Res} = kterl:seize(Pid, &lt;&lt;"key"&gt;&gt;).
...
3&gt; kterl_result:get_value(Res).
&lt;&lt;"value"&gt;&gt;
4&gt; kterl_result:get_exptime_future_seconds(Res).
9
5&gt; kterl:seize(Pid, &lt;&lt;"key"&gt;&gt;).
{error, no_record}.</pre>
<p> </p>On success seize/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_value(Result).           % The record's value.
kterl_result:get_exptime(Result).         % The record's expiration time (if set.)</pre></p>
<p><b>See also:</b> <a href="#seize-3">seize/3</a>.</p>

<h3 class="function"><a name="seize-3">seize/3</a></h3>
<div class="spec">
<p><tt>seize(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, no_record} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>

Calls /rpc/seize<p> </p>

<p>Retrieve and remove a record in one atomic operation, with the option
to specify a database and/or perform signal operations. The call
returns the record's value, and if set, the record's expiration time.</p>

<pre>% example: a process in the cluster intermittently creates a status record in the status.kct
% database, and then broadcasts a 'status_ready' signal. this function acts as a consumer. 
% it waits for that signal, seizes the record, and then performs some processing on the 
% record's value.

get_status_record(Pid) -&gt;
    case kterl:seize(Pid, "sys_status", 
                     [{database, "status.kct"},
                      {wait,     "status_ready"},
                      {waittime, 10}]) of
        {ok, Res} -&gt;
            process_status(kterl_result:get_value(Res)),
            get_status_record(Pid);
        {error, timed_out} -&gt;
            log("Status not ready after 10 seconds"),
            get_status_record(Pid);
        {error, no_record} -&gt;
            throw({error, {get_status, no_record}})
end.</pre>

<p> </p>On success seize/3 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_value(Result).           % The record's value.
kterl_result:get_exptime(Result).         % The record's expiration time (if set.)
kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#seize-2">seize/2</a>.</p>

<h3 class="function"><a name="set-2">set/2</a></h3>
<div class="spec">
<p><tt>set(Client::<a href="#type-kt_client">kt_client()</a>, KeyValue::{Key::<a href="#type-kt_key">kt_key()</a>, Value::<a href="#type-kt_value">kt_value()</a>}) -&gt; ok | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/set<p> </p>
Sets the value of a record in the primary database.
A new record is created if the key doesn't exist.
<pre>% example:

update_user_record(Pid, Record = {_Key, _Value}) -&gt;
    ok = kterl:set(Pid, Record).</pre>
<p> </p>On success set/2 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#set-3">set/3</a>, <a href="#set-4">set/4</a>.</p>

<h3 class="function"><a name="set-3">set/3</a></h3>
<div class="spec">
<p><tt>set(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, Value::<a href="#type-kt_value">kt_value()</a>) -&gt; ok | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/set<p> </p>
Sets the value of a record in the primary database. A new record is created if the key doesn't exist.
<pre>% example:

update_user_record(Pid, Key, Value) -&gt;
    ok = kterl:set(Pid, Key, Value).</pre>
<p> </p>On success set/3 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#set-2">set/2</a>.</p>

<h3 class="function"><a name="set-4">set/4</a></h3>
<div class="spec">
<p><tt>set(Client::<a href="#type-kt_client">kt_client()</a>, Key::<a href="#type-kt_key">kt_key()</a>, Value::<a href="#type-kt_value">kt_value()</a>, OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {xt, <a href="#type-kt_exptime">kt_exptime()</a>} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>
Calls /rpc/set<p> </p>

<p>Sets the value of a record in a specified database, with other
optional parameters, such as setting the destination database, an
expiration time, setting, or waiting on a signal.  A new record is
created if the key doesn't exist.</p>

<pre>% example: creates or updates a record in the cache.kct database, with an 
% expiration time 120 seconds in the future, and then sends the "cache" 
% signal to all clients waiting for that signal.

add_cache_item(Pid, Key, Value) -&gt;
     {ok, Res} = kterl:set(Pid, Key, Value, 
                    [{database, "cache.kct"}, {xt,120},
                     {signal, "cache"}, {signalbroad, true}]),
     Signaled = kterl:get_signaled_count(Res),
     {ok, Signaled}.</pre>
<p> </p>On success set/4 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#set-2">set/2</a>, <a href="#set-3">set/3</a>.</p>

<h3 class="function"><a name="set_bulk-2">set_bulk/2</a></h3>
<div class="spec">
<p><tt>set_bulk(Client::<a href="#type-kt_client">kt_client()</a>, KVL::<a href="dict.html#type-dict">dict:dict()</a> | <a href="#type-kt_kv_list">kt_kv_list()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>

Calls /rpc/set_bulk<p> </p>

<p>Stores multiple records to the primary database at once, returning the
number of records stored.  <a href="#bin_set_bulk-2"><code>bin_set_bulk/2</code></a> is significantly faster than
this call.</p>

<pre>% example:

1&gt; Records = [{"key1","val1"}, {&lt;&lt;"key2"&gt;&gt;, &lt;&lt;"val2"&gt;&gt;}, {"key3", 1234}, {"key4",1.23}].
...
2&gt; {ok, Res} = kterl:set_bulk(Pid, Records).
...
3&gt; kterl_result:get_num(Res).
4
...
4&gt; kterl_result:get_records(kterl:get_bulk(Pid, [Key || {Key,_} &lt;- Records])).
[{&lt;&lt;"key1"&gt;&gt;,&lt;&lt;"val1"&gt;&gt;},
 {&lt;&lt;"key2"&gt;&gt;,&lt;&lt;"val2"&gt;&gt;},
 {&lt;&lt;"key3"&gt;&gt;,&lt;&lt;"1234"&gt;&gt;},
 {&lt;&lt;"key4"&gt;&gt;,&lt;&lt;"1.230000"&gt;&gt;}]</pre>
<p> </p>On success set_bulk/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_num(Result).             % The result from an increment call, or a record count.</pre></p>
<p><b>See also:</b> <a href="#bin_set_bulk-2">bin_set_bulk/2</a>, <a href="#set_bulk-3">set_bulk/3</a>.</p>

<h3 class="function"><a name="set_bulk-3">set_bulk/3</a></h3>
<div class="spec">
<p><tt>set_bulk(Client::<a href="#type-kt_client">kt_client()</a>, KVL::<a href="dict.html#type-dict">dict:dict()</a> | <a href="#type-kt_kv_list">kt_kv_list()</a>, OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {atomic, boolean()} | {xt, <a href="#type-kt_exptime">kt_exptime()</a>} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>

Calls /rpc/set_bulk<p> </p>

<p>Stores multiple records at once, returning the number of records
stored. Optionally, the database and/or signal operations, and an
option to force atomicity can be specified. <a href="#bin_set_bulk-2"><code>bin_set_bulk/2</code></a> is
significantly faster than this call, but it lacks the ability to
configure signal operations, atomicity, or specify the destination
database as a string.</p>

<pre>% example: This function creates several bogus status records in the "status.kct" database.
% after the records are added, a signal "status_available" is broadcast to all listeners.
% the number of processes waiting on that signal is returned, along with the number of
% records added.

add_status_records(Pid) -&gt;
    Sttrecs = [{&lt;&lt;"status_1"&gt;&gt;,&lt;&lt;"aGVsbG8gd29ybGQsIHRoaXMgaXMgYSB0ZXN0Lg=="&gt;&gt;}
               {&lt;&lt;"status_2"&gt;&gt;,&lt;&lt;"ZG9uJ3QgcGFuaWMh"&gt;&gt;},
               {&lt;&lt;"status_3"&gt;&gt;,&lt;&lt;"Li4uIHRoZSBlbmQgLi4u"&gt;&gt;}],
    case kterl:set_bulk(Pid, Sttrecs, [{database, "status.kct"},
                                       {xt, 60 * 60 * 24},
                                       {signal, "status_available"},
                                       {signalbroad, true},
                                       {atomic, true}]) of
        {ok, Res} -&gt;
            RecsAdded = kterl_result:get_num(Res),
            NSignaled = kterl_result:get_signaled_count(Res),
            {ok, RecsAdded, NSignaled};
        Err = {error, _} -&gt;
            Err
    end.</pre>
<p> </p>On success set_bulk/3 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_num(Result).             % The result from an increment call, or a record count.
kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#bin_set_bulk-2">bin_set_bulk/2</a>, <a href="#set_bulk-2">set_bulk/2</a>.</p>

<h3 class="function"><a name="start_link-0">start_link/0</a></h3>
<div class="spec">
<p><tt>start_link() -&gt; {ok, pid()} | {error, term()}</tt><br></p>
</div><p>Connects to database @ localhost:1978 with a 5 second connection
  retry interval. Creates the connection handler and links to the calling process.</p>

<h3 class="function"><a name="start_link-1">start_link/1</a></h3>
<div class="spec">
<p><tt>start_link(Args::[{host, string()} | {port, <a href="inet.html#type-port_number">inet:port_number()</a>} | {reconnect_sleep, non_neg_integer()}]) -&gt; {ok, pid()} | {error, term()}</tt><br></p>
</div><p>Connects to 'host' on port number 'port'
  with a connection retry interval of 'reconnect_sleep' ms.
  Creates the connection handler and links to calling process.</p>

<h3 class="function"><a name="start_link-3">start_link/3</a></h3>
<div class="spec">
<p><tt>start_link(Host::string(), Port::<a href="inet.html#type-port_number">inet:port_number()</a>, ReconnectSleep::non_neg_integer()) -&gt; {ok, pid()} | {error, term()}</tt><br></p>
</div><p>Connects to Host : Port with a connection retry interval of
  ReconnectSleep ms. Creates the connection handler and links to calling
  process.</p>

<h3 class="function"><a name="status-1">status/1</a></h3>
<div class="spec">
<p><tt>status(Client::<a href="#type-kt_client">kt_client()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/status<p> </p>
Receives miscellaneous status information of the primary database.
<pre>% example:

1&gt; {ok, Res} = kterl:status(Pid),
...
2&gt; kterl_result:get_records(Res).
[{&lt;&lt;"apow"&gt;&gt;,&lt;&lt;"8"&gt;&gt;},
 {&lt;&lt;"bnum"&gt;&gt;,&lt;&lt;"65536"&gt;&gt;},
 {&lt;&lt;"chksum"&gt;&gt;,&lt;&lt;"188"&gt;&gt;},
 {&lt;&lt;"count"&gt;&gt;,&lt;&lt;"8"&gt;&gt;},
 {&lt;&lt;"cusage"&gt;&gt;,&lt;&lt;"237"&gt;&gt;},
 {&lt;&lt;"dfunit"&gt;&gt;,&lt;&lt;"0"&gt;&gt;},
 ... ]</pre>
<p> </p>On success status/1 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_records(Result).         % All records.</pre></p>
<p><b>See also:</b> <a href="#status-2">status/2</a>.</p>

<h3 class="function"><a name="status-2">status/2</a></h3>
<div class="spec">
<p><tt>status(Client::<a href="#type-kt_client">kt_client()</a>, Database::<a href="#type-kt_database">kt_database()</a>) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/status<br>
Receives miscellaneous status information of a specified database
<pre>% example:

1&gt; kterl_result:get_records(kterl:status(Pid), "test.kct")).
[{&lt;&lt;"apow"&gt;&gt;,&lt;&lt;"8"&gt;&gt;},
 {&lt;&lt;"bnum"&gt;&gt;,&lt;&lt;"65536"&gt;&gt;},
 {&lt;&lt;"chksum"&gt;&gt;,&lt;&lt;"188"&gt;&gt;},
 {&lt;&lt;"count"&gt;&gt;,&lt;&lt;"8"&gt;&gt;},
 {&lt;&lt;"cusage"&gt;&gt;,&lt;&lt;"237"&gt;&gt;},
 {&lt;&lt;"dfunit"&gt;&gt;,&lt;&lt;"0"&gt;&gt;},
 ... ]</pre>
<p> </p>On success status/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_records(Result).         % All records.</pre></p>
<p><b>See also:</b> <a href="#status-1">status/1</a>.</p>

<h3 class="function"><a name="stop-1">stop/1</a></h3>
<div class="spec">
<p><tt>stop(Client::pid()) -&gt; ok</tt><br></p>
</div><p>Gracefully closes the tcp connection and stops the gen_server
  connection handler.</p>

<h3 class="function"><a name="synchronize-1">synchronize/1</a></h3>
<div class="spec">
<p><tt>synchronize(Client::<a href="#type-kt_client">kt_client()</a>) -&gt; ok | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/synchronize<p> </p>
Synchronize the primary database's updated contents with the file and the device.
<pre>% example:

1&gt; kterl:synchronize(Pid).
ok</pre>
<p> </p>On success synchronize/1 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#synchronize-2">synchronize/2</a>.</p>

<h3 class="function"><a name="synchronize-2">synchronize/2</a></h3>
<div class="spec">
<p><tt>synchronize(Client::<a href="#type-kt_client">kt_client()</a>, OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {hard, boolean()} | {command, binary() | string()} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p><p>Calls /rpc/synchronize<br></p>

<p>Synchronize a specified database's updated contents with the file and
the device. Refer to the Kyoto Tycoon documentation for more
information on the hard and command arguments.</p>

<pre>% example:
 
synchronize_kt_database(Pid, Database) -&gt;
    case kterl:synchronize(Pid, [{database, Database},{hard, true}]) of
        {ok,_} -&gt; ok;
        Err -&gt; Err
    end.

1&gt; synchronize_kt_database(Pid, "database.kct").
ok</pre>
<p> </p>On success synchronize/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#synchronize-1">synchronize/1</a>.</p>

<h3 class="function"><a name="tune_replication-2">tune_replication/2</a></h3>
<div class="spec">
<p><tt>tune_replication(Client::<a href="#type-kt_client">kt_client()</a>, OptArgs::[{host, binary() | string()} | {port, non_neg_integer()} | {ts, non_neg_integer()} | {iv, non_neg_integer()} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/tune_replication<p> </p><p>
Sets the server's replication configuration. See the Kyoto Tycoon documentation for further information.</p>

<p> </p>On success tune_replication/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre>
</p>

<h3 class="function"><a name="vacuum-1">vacuum/1</a></h3>
<div class="spec">
<p><tt>vacuum(Client::<a href="#type-kt_client">kt_client()</a>) -&gt; ok | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>

Calls /rpc/vacuum<p> </p>

<p>Scans the primary database and eliminates regions of expired records.</p>

<pre>1&gt; ok = kterl:vacuum(Pid).
ok</pre>
<p> </p>On success vacuum/1 returns <code>'ok'</code>.<p> </p></p>
<p><b>See also:</b> <a href="#vacuum-2">vacuum/2</a>.</p>

<h3 class="function"><a name="vacuum-2">vacuum/2</a></h3>
<div class="spec">
<p><tt>vacuum(Client::<a href="#type-kt_client">kt_client()</a>, OptArgs::[{database, <a href="#type-kt_database">kt_database()</a>} | {step, non_neg_integer()} | {wait, binary() | string()} | {waittime, binary() | string() | non_neg_integer()} | {signal, binary() | string()} | {signalbroad, boolean()}]) -&gt; {ok, <a href="#type-kt_http_result">kt_http_result()</a>} | {error, timed_out} | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>

Calls /rpc/vacuum<p> </p>

<p>Scans a database and eliminates regions of expired records. Two optional
parameters to note are 'database', which configures the database to vacuum,
and 'step', which configures the number of steps in the vacuum operation.
If 'step' is omitted or equal to 0, the whole database region is scanned.
Signal/wait operations are available through this call, as well.</p>

<pre>% example: waits for "vacuum_database" signal for 2 hours, and then
% performs a vacuum on the entire "session.kct" database.

wait_vacuum(Pid) -&gt;
    case kterl:vacuum(Pid, [{database, "session.kct"},
                            {wait,     "vacuum_database"},
                            {waittime, 2 * 60 * 60}]) of
        {ok, _} -&gt;
            ok;
        Error = {error, _} -&gt;
            Error
    end.</pre>
<p> </p>On success vacuum/2 will return <code>{ok, Result}</code>. The <code>Result</code> can then be passed to the following function(s) to access:<p> </p><pre>kterl_result:get_signaled_count(Result).  % The number of clients signaled (if 'signal' was passed to the call.)</pre></p>
<p><b>See also:</b> <a href="#vacuum-1">vacuum/1</a>.</p>

<h3 class="function"><a name="void-1">void/1</a></h3>
<div class="spec">
<p><tt>void(Client::<a href="#type-kt_client">kt_client()</a>) -&gt; ok | <a href="#type-kt_http_error">kt_http_error()</a></tt><br></p>
</div><p>Calls /rpc/void<p> </p>
Pings the server.
<pre>% example:

is_kt_connected(Pid) -&gt;
    ok == kterl:void(Pid).</pre>

<p> </p>On success void/1 returns <code>'ok'</code>.<p> </p>
</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Feb 27 2017, 22:27:25.</i></p>
</body>
</html>
